import { Debug } from './debug.js';

// id for debug tracing
const TRACEID = 'Preprocessor';

// accepted keywords
const KEYWORD = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g;

// #define EXPRESSION
const DEFINE = /define[ \t]+([^\n]+)\r?(?:\n|$)/g;

// #extension IDENTIFIER : enabled
const EXTENSION = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g;

// #undef EXPRESSION
const UNDEF = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g;

// #ifdef/#ifndef SOMEDEFINE, #if EXPRESSION
const IF = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;

// #endif/#else or #elif EXPRESSION
const ENDIF = /(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g;

// identifier
const IDENTIFIER = /([\w-]+)/;

// [!]defined(EXPRESSION)
const DEFINED = /(!|\s)?defined\(([\w-]+)\)/;

// currently unsupported characters in the expression: | & < > = + -
const INVALID = /[><=|&+-]/g;

/**
 * Pure static class implementing subset of C-style preprocessor.
 * inspired by: https://github.com/dcodeIO/Preprocessor.js
 *
 * @ignore
 */
class Preprocessor {
  /**
   * Run c-like preprocessor on the source code, and resolves the code based on the defines and ifdefs
   *
   * @param {string} source - The source code to work on.
   * @param {boolean} [stripUnusedColorAttachments] - If true, strips unused color attachments.
   * @returns {string|null} Returns preprocessed source code, or null in case of error.
   */
  static run(source, stripUnusedColorAttachments = false) {
    // strips comments, handles // and many cases of /*
    source = source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');

    // right trim each line
    source = source.split(/\r?\n/).map(line => line.trimEnd()).join('\n');

    // generate defines to remove unused color attachments
    const defines = new Map();
    if (stripUnusedColorAttachments) {
      // find out how many times pcFragColorX is used (see gles3.js)
      const counts = new Map();
      const regex = /(pcFragColor[1-8])\b/g;
      const matches = source.match(regex);
      matches == null || matches.forEach(match => {
        var _counts$get;
        const index = parseInt(match.charAt(match.length - 1), 10);
        counts.set(index, ((_counts$get = counts.get(index)) != null ? _counts$get : 0) + 1);
      });

      // if pcFragColorX is used only once, remove it
      counts.forEach((count, index) => {
        if (count === 1) {
          defines.set(`REMOVE_COLOR_ATTACHMENT_${index}`, '');
        }
      });
    }

    // preprocess defines / ifdefs ..
    source = this._preprocess(source, defines);

    // extract defines that evaluate to an integer number
    const intDefines = new Map();
    defines.forEach((value, key) => {
      if (Number.isInteger(parseFloat(value)) && !value.includes('.')) {
        intDefines.set(key, value);
      }
    });

    // remove empty lines
    source = this.RemoveEmptyLines(source);

    // process array sizes
    source = this.processArraySize(source, intDefines);
    return source;
  }
  static processArraySize(source, intDefines) {
    if (source !== null) {
      // replace lines containing "[intDefine]" with their values, so that we know the array size for WebGPU uniform buffer
      // example: weight[SAMPLES] => float weight[11] in case there was a "define SAMPLES 11" in the source code
      intDefines.forEach((value, key) => {
        source = source.replace(new RegExp(`\\[${key}\\]`, 'g'), `[${value}]`);
      });
    }
    return source;
  }
  static RemoveEmptyLines(source) {
    if (source !== null) {
      source = source.split(/\r?\n/)

      // convert lines with only white space into empty string
      .map(line => line.trim() === '' ? '' : line).join('\n');

      // remove more than 1 consecutive empty lines
      source = source.replace(/(\n\n){3,}/gm, '\n\n');
    }
    return source;
  }

  /**
   * Process source code, and resolves the code based on the defines and ifdefs.
   *
   * @param {string} source - The source code to work on.
   * @param {Map<string, string>} defines - Supplied defines which are used in addition to those
   * defined in the source code. Maps a define name to its value. Note that the map is modified
   * by the function.
   * @returns {string} Returns preprocessed source code.
   */
  static _preprocess(source, defines = new Map()) {
    const originalSource = source;

    // stack, storing info about ifdef blocks
    const stack = [];

    // true if the function encounter a problem
    let error = false;
    let match;
    while ((match = KEYWORD.exec(source)) !== null) {
      const keyword = match[1];
      switch (keyword) {
        case 'define':
          {
            // read the rest of the define line
            DEFINE.lastIndex = match.index;
            const define = DEFINE.exec(source);
            Debug.assert(define, `Invalid [${keyword}]: ${source.substring(match.index, match.index + 100)}...`);
            error || (error = define === null);
            const expression = define[1];

            // split it to identifier name and a value
            IDENTIFIER.lastIndex = define.index;
            const identifierValue = IDENTIFIER.exec(expression);
            const identifier = identifierValue[1];
            let value = expression.substring(identifier.length).trim();
            if (value === "") value = "true";

            // are we inside if-blocks that are accepted
            const keep = Preprocessor._keep(stack);
            if (keep) {
              defines.set(identifier, value);
            }
            Debug.trace(TRACEID, `${keyword}: [${identifier}] ${value} ${keep ? "" : "IGNORED"}`);

            // continue on the next line
            KEYWORD.lastIndex = define.index + define[0].length;
            break;
          }
        case 'undef':
          {
            // read the rest of the define line
            UNDEF.lastIndex = match.index;
            const undef = UNDEF.exec(source);
            const identifier = undef[1].trim();

            // are we inside if-blocks that are accepted
            const keep = Preprocessor._keep(stack);

            // remove it from defines
            if (keep) {
              defines.delete(identifier);
            }
            Debug.trace(TRACEID, `${keyword}: [${identifier}] ${keep ? "" : "IGNORED"}`);

            // continue on the next line
            KEYWORD.lastIndex = undef.index + undef[0].length;
            break;
          }
        case 'extension':
          {
            EXTENSION.lastIndex = match.index;
            const extension = EXTENSION.exec(source);
            Debug.assert(extension, `Invalid [${keyword}]: ${source.substring(match.index, match.index + 100)}...`);
            error || (error = extension === null);
            if (extension) {
              const identifier = extension[1];

              // are we inside if-blocks that are accepted
              const keep = Preprocessor._keep(stack);
              if (keep) {
                defines.set(identifier, "true");
              }
              Debug.trace(TRACEID, `${keyword}: [${identifier}] ${keep ? "" : "IGNORED"}`);
            }

            // continue on the next line
            KEYWORD.lastIndex = extension.index + extension[0].length;
            break;
          }
        case 'ifdef':
        case 'ifndef':
        case 'if':
          {
            // read the if line
            IF.lastIndex = match.index;
            const iff = IF.exec(source);
            const expression = iff[2];

            // evaluate expression
            const evaluated = Preprocessor.evaluate(expression, defines);
            error || (error = evaluated.error);
            let result = evaluated.result;
            if (keyword === 'ifndef') {
              result = !result;
            }

            // add info to the stack (to be handled later)
            stack.push({
              anyKeep: result,
              // true if any branch was already accepted
              keep: result,
              // true if this branch is being taken
              start: match.index,
              // start index if IF line
              end: IF.lastIndex // end index of IF line
            });

            Debug.trace(TRACEID, `${keyword}: [${expression}] => ${result}`);

            // continue on the next line
            KEYWORD.lastIndex = iff.index + iff[0].length;
            break;
          }
        case 'endif':
        case 'else':
        case 'elif':
          {
            // match the endif
            ENDIF.lastIndex = match.index;
            const endif = ENDIF.exec(source);
            const blockInfo = stack.pop();

            // code between if and endif
            const blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : "";
            Debug.trace(TRACEID, `${keyword}: [previous block] => ${blockCode !== ""}`);

            // cut out the IF and ENDIF lines, leave block if required
            source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);
            KEYWORD.lastIndex = blockInfo.start + blockCode.length;

            // handle else if
            const endifCommand = endif[1];
            if (endifCommand === 'else' || endifCommand === 'elif') {
              // if any branch was already accepted, all else branches need to fail regardless of the result
              let result = false;
              if (!blockInfo.anyKeep) {
                if (endifCommand === 'else') {
                  result = !blockInfo.keep;
                } else {
                  const evaluated = Preprocessor.evaluate(endif[2], defines);
                  result = evaluated.result;
                  error || (error = evaluated.error);
                }
              }

              // add back to stack
              stack.push({
                anyKeep: blockInfo.anyKeep || result,
                keep: result,
                start: KEYWORD.lastIndex,
                end: KEYWORD.lastIndex
              });
              Debug.trace(TRACEID, `${keyword}: [${endif[2]}] => ${result}`);
            }
            break;
          }
      }
    }
    if (error) {
      console.warn("Failed to preprocess shader: ", {
        source: originalSource
      });
      return originalSource;
    }
    return source;
  }

  // function returns true if the evaluation is inside keep branches
  static _keep(stack) {
    for (let i = 0; i < stack.length; i++) {
      if (!stack[i].keep) return false;
    }
    return true;
  }

  /**
   * Very simple expression evaluation, handles cases:
   * expression
   * defined(expression)
   * !defined(expression)
   *
   * But does not handle more complex cases, which would require more complex system:
   * defined(A) || defined(B)
   */
  static evaluate(expression, defines) {
    const correct = INVALID.exec(expression) === null;
    Debug.assert(correct, `Resolving expression like this is not supported: ${expression}`);

    // if the format is defined(expression), extract expression
    let invert = false;
    const defined = DEFINED.exec(expression);
    if (defined) {
      invert = defined[1] === '!';
      expression = defined[2];
    }

    // test if expression define exists
    expression = expression.trim();
    let exists = defines.has(expression);

    // handle inversion
    if (invert) {
      exists = !exists;
    }
    return {
      result: exists,
      error: !correct
    };
  }
}

export { Preprocessor };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlcHJvY2Vzc29yLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29yZS9wcmVwcm9jZXNzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuL2RlYnVnLmpzJztcblxuLy8gaWQgZm9yIGRlYnVnIHRyYWNpbmdcbmNvbnN0IFRSQUNFSUQgPSAnUHJlcHJvY2Vzc29yJztcblxuLy8gYWNjZXB0ZWQga2V5d29yZHNcbmNvbnN0IEtFWVdPUkQgPSAvWyBcXHRdKiMoaWZuP2RlZnxpZnxlbmRpZnxlbHNlfGVsaWZ8ZGVmaW5lfHVuZGVmfGV4dGVuc2lvbikvZztcblxuLy8gI2RlZmluZSBFWFBSRVNTSU9OXG5jb25zdCBERUZJTkUgPSAvZGVmaW5lWyBcXHRdKyhbXlxcbl0rKVxccj8oPzpcXG58JCkvZztcblxuLy8gI2V4dGVuc2lvbiBJREVOVElGSUVSIDogZW5hYmxlZFxuY29uc3QgRVhURU5TSU9OID0gL2V4dGVuc2lvblsgXFx0XSsoW1xcdy1dKylbIFxcdF0qOlsgXFx0XSooZW5hYmxlfHJlcXVpcmUpL2c7XG5cbi8vICN1bmRlZiBFWFBSRVNTSU9OXG5jb25zdCBVTkRFRiA9IC91bmRlZlsgXFx0XSsoW15cXG5dKylcXHI/KD86XFxufCQpL2c7XG5cbi8vICNpZmRlZi8jaWZuZGVmIFNPTUVERUZJTkUsICNpZiBFWFBSRVNTSU9OXG5jb25zdCBJRiA9IC8oaWZkZWZ8aWZuZGVmfGlmKVsgXFx0XSooW15cXHJcXG5dKylcXHI/XFxuL2c7XG5cbi8vICNlbmRpZi8jZWxzZSBvciAjZWxpZiBFWFBSRVNTSU9OXG5jb25zdCBFTkRJRiA9IC8oZW5kaWZ8ZWxzZXxlbGlmKShbIFxcdF0rW15cXHJcXG5dKyk/XFxyPyg/OlxcbnwkKS9nO1xuXG4vLyBpZGVudGlmaWVyXG5jb25zdCBJREVOVElGSUVSID0gLyhbXFx3LV0rKS87XG5cbi8vIFshXWRlZmluZWQoRVhQUkVTU0lPTilcbmNvbnN0IERFRklORUQgPSAvKCF8XFxzKT9kZWZpbmVkXFwoKFtcXHctXSspXFwpLztcblxuLy8gY3VycmVudGx5IHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgaW4gdGhlIGV4cHJlc3Npb246IHwgJiA8ID4gPSArIC1cbmNvbnN0IElOVkFMSUQgPSAvWz48PXwmKy1dL2c7XG5cbi8qKlxuICogUHVyZSBzdGF0aWMgY2xhc3MgaW1wbGVtZW50aW5nIHN1YnNldCBvZiBDLXN0eWxlIHByZXByb2Nlc3Nvci5cbiAqIGluc3BpcmVkIGJ5OiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9QcmVwcm9jZXNzb3IuanNcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIFByZXByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogUnVuIGMtbGlrZSBwcmVwcm9jZXNzb3Igb24gdGhlIHNvdXJjZSBjb2RlLCBhbmQgcmVzb2x2ZXMgdGhlIGNvZGUgYmFzZWQgb24gdGhlIGRlZmluZXMgYW5kIGlmZGVmc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSB0byB3b3JrIG9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0cmlwVW51c2VkQ29sb3JBdHRhY2htZW50c10gLSBJZiB0cnVlLCBzdHJpcHMgdW51c2VkIGNvbG9yIGF0dGFjaG1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gUmV0dXJucyBwcmVwcm9jZXNzZWQgc291cmNlIGNvZGUsIG9yIG51bGwgaW4gY2FzZSBvZiBlcnJvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgcnVuKHNvdXJjZSwgc3RyaXBVbnVzZWRDb2xvckF0dGFjaG1lbnRzID0gZmFsc2UpIHtcblxuICAgICAgICAvLyBzdHJpcHMgY29tbWVudHMsIGhhbmRsZXMgLy8gYW5kIG1hbnkgY2FzZXMgb2YgLypcbiAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98KFteXFxcXDpdfF4pXFwvXFwvLiokL2dtLCAnJDEnKTtcblxuICAgICAgICAvLyByaWdodCB0cmltIGVhY2ggbGluZVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKVxuICAgICAgICAgICAgLm1hcChsaW5lID0+IGxpbmUudHJpbUVuZCgpKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIGRlZmluZXMgdG8gcmVtb3ZlIHVudXNlZCBjb2xvciBhdHRhY2htZW50c1xuICAgICAgICBjb25zdCBkZWZpbmVzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoc3RyaXBVbnVzZWRDb2xvckF0dGFjaG1lbnRzKSB7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IGhvdyBtYW55IHRpbWVzIHBjRnJhZ0NvbG9yWCBpcyB1c2VkIChzZWUgZ2xlczMuanMpXG4gICAgICAgICAgICBjb25zdCBjb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCByZWdleCA9IC8ocGNGcmFnQ29sb3JbMS04XSlcXGIvZztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBzb3VyY2UubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgbWF0Y2hlcz8uZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KG1hdGNoLmNoYXJBdChtYXRjaC5sZW5ndGggLSAxKSwgMTApO1xuICAgICAgICAgICAgICAgIGNvdW50cy5zZXQoaW5kZXgsIChjb3VudHMuZ2V0KGluZGV4KSA/PyAwKSArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHBjRnJhZ0NvbG9yWCBpcyB1c2VkIG9ubHkgb25jZSwgcmVtb3ZlIGl0XG4gICAgICAgICAgICBjb3VudHMuZm9yRWFjaCgoY291bnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZXMuc2V0KGBSRU1PVkVfQ09MT1JfQVRUQUNITUVOVF8ke2luZGV4fWAsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXByb2Nlc3MgZGVmaW5lcyAvIGlmZGVmcyAuLlxuICAgICAgICBzb3VyY2UgPSB0aGlzLl9wcmVwcm9jZXNzKHNvdXJjZSwgZGVmaW5lcyk7XG5cbiAgICAgICAgLy8gZXh0cmFjdCBkZWZpbmVzIHRoYXQgZXZhbHVhdGUgdG8gYW4gaW50ZWdlciBudW1iZXJcbiAgICAgICAgY29uc3QgaW50RGVmaW5lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZGVmaW5lcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgIXZhbHVlLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICBpbnREZWZpbmVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IGxpbmVzXG4gICAgICAgIHNvdXJjZSA9IHRoaXMuUmVtb3ZlRW1wdHlMaW5lcyhzb3VyY2UpO1xuXG4gICAgICAgIC8vIHByb2Nlc3MgYXJyYXkgc2l6ZXNcbiAgICAgICAgc291cmNlID0gdGhpcy5wcm9jZXNzQXJyYXlTaXplKHNvdXJjZSwgaW50RGVmaW5lcyk7XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJvY2Vzc0FycmF5U2l6ZShzb3VyY2UsIGludERlZmluZXMpIHtcblxuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIGxpbmVzIGNvbnRhaW5pbmcgXCJbaW50RGVmaW5lXVwiIHdpdGggdGhlaXIgdmFsdWVzLCBzbyB0aGF0IHdlIGtub3cgdGhlIGFycmF5IHNpemUgZm9yIFdlYkdQVSB1bmlmb3JtIGJ1ZmZlclxuICAgICAgICAgICAgLy8gZXhhbXBsZTogd2VpZ2h0W1NBTVBMRVNdID0+IGZsb2F0IHdlaWdodFsxMV0gaW4gY2FzZSB0aGVyZSB3YXMgYSBcImRlZmluZSBTQU1QTEVTIDExXCIgaW4gdGhlIHNvdXJjZSBjb2RlXG4gICAgICAgICAgICBpbnREZWZpbmVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShuZXcgUmVnRXhwKGBcXFxcWyR7a2V5fVxcXFxdYCwgJ2cnKSwgYFske3ZhbHVlfV1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgUmVtb3ZlRW1wdHlMaW5lcyhzb3VyY2UpIHtcblxuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKVxuXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBsaW5lcyB3aXRoIG9ubHkgd2hpdGUgc3BhY2UgaW50byBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICAubWFwKGxpbmUgPT4gKGxpbmUudHJpbSgpID09PSAnJyA/ICcnIDogbGluZSkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgbW9yZSB0aGFuIDEgY29uc2VjdXRpdmUgZW1wdHkgbGluZXNcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC8oXFxuXFxuKXszLH0vZ20sICdcXG5cXG4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBzb3VyY2UgY29kZSwgYW5kIHJlc29sdmVzIHRoZSBjb2RlIGJhc2VkIG9uIHRoZSBkZWZpbmVzIGFuZCBpZmRlZnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIHRvIHdvcmsgb24uXG4gICAgICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSBkZWZpbmVzIC0gU3VwcGxpZWQgZGVmaW5lcyB3aGljaCBhcmUgdXNlZCBpbiBhZGRpdGlvbiB0byB0aG9zZVxuICAgICAqIGRlZmluZWQgaW4gdGhlIHNvdXJjZSBjb2RlLiBNYXBzIGEgZGVmaW5lIG5hbWUgdG8gaXRzIHZhbHVlLiBOb3RlIHRoYXQgdGhlIG1hcCBpcyBtb2RpZmllZFxuICAgICAqIGJ5IHRoZSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHByZXByb2Nlc3NlZCBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgX3ByZXByb2Nlc3Moc291cmNlLCBkZWZpbmVzID0gbmV3IE1hcCgpKSB7XG5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAgICAgLy8gc3RhY2ssIHN0b3JpbmcgaW5mbyBhYm91dCBpZmRlZiBibG9ja3NcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICAgICAgICAvLyB0cnVlIGlmIHRoZSBmdW5jdGlvbiBlbmNvdW50ZXIgYSBwcm9ibGVtXG4gICAgICAgIGxldCBlcnJvciA9IGZhbHNlO1xuXG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IEtFWVdPUkQuZXhlYyhzb3VyY2UpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBzd2l0Y2ggKGtleXdvcmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkZWZpbmUnOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCB0aGUgcmVzdCBvZiB0aGUgZGVmaW5lIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgREVGSU5FLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZpbmUgPSBERUZJTkUuZXhlYyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5hc3NlcnQoZGVmaW5lLCBgSW52YWxpZCBbJHtrZXl3b3JkfV06ICR7c291cmNlLnN1YnN0cmluZyhtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyAxMDApfS4uLmApO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciB8fD0gZGVmaW5lID09PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVmaW5lWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IGl0IHRvIGlkZW50aWZpZXIgbmFtZSBhbmQgYSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBJREVOVElGSUVSLmxhc3RJbmRleCA9IGRlZmluZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllclZhbHVlID0gSURFTlRJRklFUi5leGVjKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWRlbnRpZmllclZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBleHByZXNzaW9uLnN1YnN0cmluZyhpZGVudGlmaWVyLmxlbmd0aCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHZhbHVlID0gXCJ0cnVlXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHdlIGluc2lkZSBpZi1ibG9ja3MgdGhhdCBhcmUgYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2VlcCA9IFByZXByb2Nlc3Nvci5fa2VlcChzdGFjayk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZXMuc2V0KGlkZW50aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLnRyYWNlKFRSQUNFSUQsIGAke2tleXdvcmR9OiBbJHtpZGVudGlmaWVyfV0gJHt2YWx1ZX0gJHtrZWVwID8gXCJcIiA6IFwiSUdOT1JFRFwifWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgS0VZV09SRC5sYXN0SW5kZXggPSBkZWZpbmUuaW5kZXggKyBkZWZpbmVbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZic6IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkIHRoZSByZXN0IG9mIHRoZSBkZWZpbmUgbGluZVxuICAgICAgICAgICAgICAgICAgICBVTkRFRi5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5kZWYgPSBVTkRFRi5leGVjKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB1bmRlZlsxXS50cmltKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHdlIGluc2lkZSBpZi1ibG9ja3MgdGhhdCBhcmUgYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2VlcCA9IFByZXByb2Nlc3Nvci5fa2VlcChzdGFjayk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gZGVmaW5lc1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lcy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy50cmFjZShUUkFDRUlELCBgJHtrZXl3b3JkfTogWyR7aWRlbnRpZmllcn1dICR7a2VlcCA/IFwiXCIgOiBcIklHTk9SRURcIn1gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBvbiB0aGUgbmV4dCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIEtFWVdPUkQubGFzdEluZGV4ID0gdW5kZWYuaW5kZXggKyB1bmRlZlswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVuc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgRVhURU5TSU9OLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBFWFRFTlNJT04uZXhlYyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5hc3NlcnQoZXh0ZW5zaW9uLCBgSW52YWxpZCBbJHtrZXl3b3JkfV06ICR7c291cmNlLnN1YnN0cmluZyhtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyAxMDApfS4uLmApO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciB8fD0gZXh0ZW5zaW9uID09PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gZXh0ZW5zaW9uWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmUgd2UgaW5zaWRlIGlmLWJsb2NrcyB0aGF0IGFyZSBhY2NlcHRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2VlcCA9IFByZXByb2Nlc3Nvci5fa2VlcChzdGFjayk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lcy5zZXQoaWRlbnRpZmllciwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy50cmFjZShUUkFDRUlELCBgJHtrZXl3b3JkfTogWyR7aWRlbnRpZmllcn1dICR7a2VlcCA/IFwiXCIgOiBcIklHTk9SRURcIn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgS0VZV09SRC5sYXN0SW5kZXggPSBleHRlbnNpb24uaW5kZXggKyBleHRlbnNpb25bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpZmRlZic6XG4gICAgICAgICAgICAgICAgY2FzZSAnaWZuZGVmJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpZic6IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkIHRoZSBpZiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIElGLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZmYgPSBJRi5leGVjKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpZmZbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmFsdWF0ZWQgPSBQcmVwcm9jZXNzb3IuZXZhbHVhdGUoZXhwcmVzc2lvbiwgZGVmaW5lcyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yIHx8PSBldmFsdWF0ZWQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBldmFsdWF0ZWQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ2lmbmRlZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICFyZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaW5mbyB0byB0aGUgc3RhY2sgKHRvIGJlIGhhbmRsZWQgbGF0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgYW55S2VlcDogcmVzdWx0LCAgICAgICAgLy8gdHJ1ZSBpZiBhbnkgYnJhbmNoIHdhcyBhbHJlYWR5IGFjY2VwdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwOiByZXN1bHQsICAgICAgICAgICAvLyB0cnVlIGlmIHRoaXMgYnJhbmNoIGlzIGJlaW5nIHRha2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsICAgICAvLyBzdGFydCBpbmRleCBpZiBJRiBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IElGLmxhc3RJbmRleCAgICAgICAvLyBlbmQgaW5kZXggb2YgSUYgbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy50cmFjZShUUkFDRUlELCBgJHtrZXl3b3JkfTogWyR7ZXhwcmVzc2lvbn1dID0+ICR7cmVzdWx0fWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgS0VZV09SRC5sYXN0SW5kZXggPSBpZmYuaW5kZXggKyBpZmZbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICdlbmRpZic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZWxzZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZWxpZic6IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCB0aGUgZW5kaWZcbiAgICAgICAgICAgICAgICAgICAgRU5ESUYubGFzdEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZGlmID0gRU5ESUYuZXhlYyhzb3VyY2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrSW5mbyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgYmV0d2VlbiBpZiBhbmQgZW5kaWZcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tDb2RlID0gYmxvY2tJbmZvLmtlZXAgPyBzb3VyY2Uuc3Vic3RyaW5nKGJsb2NrSW5mby5lbmQsIG1hdGNoLmluZGV4KSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIERlYnVnLnRyYWNlKFRSQUNFSUQsIGAke2tleXdvcmR9OiBbcHJldmlvdXMgYmxvY2tdID0+ICR7YmxvY2tDb2RlICE9PSBcIlwifWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1dCBvdXQgdGhlIElGIGFuZCBFTkRJRiBsaW5lcywgbGVhdmUgYmxvY2sgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBibG9ja0luZm8uc3RhcnQpICsgYmxvY2tDb2RlICsgc291cmNlLnN1YnN0cmluZyhFTkRJRi5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBLRVlXT1JELmxhc3RJbmRleCA9IGJsb2NrSW5mby5zdGFydCArIGJsb2NrQ29kZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIGVsc2UgaWZcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kaWZDb21tYW5kID0gZW5kaWZbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRpZkNvbW1hbmQgPT09ICdlbHNlJyB8fCBlbmRpZkNvbW1hbmQgPT09ICdlbGlmJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgYnJhbmNoIHdhcyBhbHJlYWR5IGFjY2VwdGVkLCBhbGwgZWxzZSBicmFuY2hlcyBuZWVkIHRvIGZhaWwgcmVnYXJkbGVzcyBvZiB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJsb2NrSW5mby5hbnlLZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZGlmQ29tbWFuZCA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICFibG9ja0luZm8ua2VlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmFsdWF0ZWQgPSBQcmVwcm9jZXNzb3IuZXZhbHVhdGUoZW5kaWZbMl0sIGRlZmluZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZWQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciB8fD0gZXZhbHVhdGVkLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGJhY2sgdG8gc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueUtlZXA6IGJsb2NrSW5mby5hbnlLZWVwIHx8IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZWVwOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IEtFWVdPUkQubGFzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogS0VZV09SRC5sYXN0SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcudHJhY2UoVFJBQ0VJRCwgYCR7a2V5d29yZH06IFske2VuZGlmWzJdfV0gPT4gJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBwcmVwcm9jZXNzIHNoYWRlcjogXCIsIHsgc291cmNlOiBvcmlnaW5hbFNvdXJjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIHRoZSBldmFsdWF0aW9uIGlzIGluc2lkZSBrZWVwIGJyYW5jaGVzXG4gICAgc3RhdGljIF9rZWVwKHN0YWNrKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghc3RhY2tbaV0ua2VlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJ5IHNpbXBsZSBleHByZXNzaW9uIGV2YWx1YXRpb24sIGhhbmRsZXMgY2FzZXM6XG4gICAgICogZXhwcmVzc2lvblxuICAgICAqIGRlZmluZWQoZXhwcmVzc2lvbilcbiAgICAgKiAhZGVmaW5lZChleHByZXNzaW9uKVxuICAgICAqXG4gICAgICogQnV0IGRvZXMgbm90IGhhbmRsZSBtb3JlIGNvbXBsZXggY2FzZXMsIHdoaWNoIHdvdWxkIHJlcXVpcmUgbW9yZSBjb21wbGV4IHN5c3RlbTpcbiAgICAgKiBkZWZpbmVkKEEpIHx8IGRlZmluZWQoQilcbiAgICAgKi9cbiAgICBzdGF0aWMgZXZhbHVhdGUoZXhwcmVzc2lvbiwgZGVmaW5lcykge1xuXG4gICAgICAgIGNvbnN0IGNvcnJlY3QgPSBJTlZBTElELmV4ZWMoZXhwcmVzc2lvbikgPT09IG51bGw7XG4gICAgICAgIERlYnVnLmFzc2VydChjb3JyZWN0LCBgUmVzb2x2aW5nIGV4cHJlc3Npb24gbGlrZSB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQ6ICR7ZXhwcmVzc2lvbn1gKTtcblxuICAgICAgICAvLyBpZiB0aGUgZm9ybWF0IGlzIGRlZmluZWQoZXhwcmVzc2lvbiksIGV4dHJhY3QgZXhwcmVzc2lvblxuICAgICAgICBsZXQgaW52ZXJ0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlZmluZWQgPSBERUZJTkVELmV4ZWMoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChkZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnZlcnQgPSBkZWZpbmVkWzFdID09PSAnISc7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gZGVmaW5lZFsyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlc3QgaWYgZXhwcmVzc2lvbiBkZWZpbmUgZXhpc3RzXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnRyaW0oKTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IGRlZmluZXMuaGFzKGV4cHJlc3Npb24pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbnZlcnNpb25cbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgICAgZXhpc3RzID0gIWV4aXN0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGV4aXN0cyxcbiAgICAgICAgICAgIGVycm9yOiAhY29ycmVjdFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUHJlcHJvY2Vzc29yIH07XG4iXSwibmFtZXMiOlsiVFJBQ0VJRCIsIktFWVdPUkQiLCJERUZJTkUiLCJFWFRFTlNJT04iLCJVTkRFRiIsIklGIiwiRU5ESUYiLCJJREVOVElGSUVSIiwiREVGSU5FRCIsIklOVkFMSUQiLCJQcmVwcm9jZXNzb3IiLCJydW4iLCJzb3VyY2UiLCJzdHJpcFVudXNlZENvbG9yQXR0YWNobWVudHMiLCJyZXBsYWNlIiwic3BsaXQiLCJtYXAiLCJsaW5lIiwidHJpbUVuZCIsImpvaW4iLCJkZWZpbmVzIiwiTWFwIiwiY291bnRzIiwicmVnZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJmb3JFYWNoIiwiX2NvdW50cyRnZXQiLCJpbmRleCIsInBhcnNlSW50IiwiY2hhckF0IiwibGVuZ3RoIiwic2V0IiwiZ2V0IiwiY291bnQiLCJfcHJlcHJvY2VzcyIsImludERlZmluZXMiLCJ2YWx1ZSIsImtleSIsIk51bWJlciIsImlzSW50ZWdlciIsInBhcnNlRmxvYXQiLCJpbmNsdWRlcyIsIlJlbW92ZUVtcHR5TGluZXMiLCJwcm9jZXNzQXJyYXlTaXplIiwiUmVnRXhwIiwidHJpbSIsIm9yaWdpbmFsU291cmNlIiwic3RhY2siLCJlcnJvciIsImV4ZWMiLCJrZXl3b3JkIiwibGFzdEluZGV4IiwiZGVmaW5lIiwiRGVidWciLCJhc3NlcnQiLCJzdWJzdHJpbmciLCJleHByZXNzaW9uIiwiaWRlbnRpZmllclZhbHVlIiwiaWRlbnRpZmllciIsImtlZXAiLCJfa2VlcCIsInRyYWNlIiwidW5kZWYiLCJkZWxldGUiLCJleHRlbnNpb24iLCJpZmYiLCJldmFsdWF0ZWQiLCJldmFsdWF0ZSIsInJlc3VsdCIsInB1c2giLCJhbnlLZWVwIiwic3RhcnQiLCJlbmQiLCJlbmRpZiIsImJsb2NrSW5mbyIsInBvcCIsImJsb2NrQ29kZSIsImVuZGlmQ29tbWFuZCIsImNvbnNvbGUiLCJ3YXJuIiwiaSIsImNvcnJlY3QiLCJpbnZlcnQiLCJkZWZpbmVk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
