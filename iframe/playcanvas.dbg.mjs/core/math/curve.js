import { extend } from '../core.js';
import { CURVE_SMOOTHSTEP } from './constants.js';
import { CurveEvaluator } from './curve-evaluator.js';

/**
 * A curve is a collection of keys (time/value pairs). The shape of the curve is defined by its
 * type that specifies an interpolation scheme for the keys.
 *
 * @category Math
 */
class Curve {
  /**
   * Creates a new Curve instance.
   *
   * @param {number[]} [data] - An array of keys (pairs of numbers with the time first and value
   * second).
   * @example
   * const curve = new pc.Curve([
   *     0, 0,        // At 0 time, value of 0
   *     0.33, 2,     // At 0.33 time, value of 2
   *     0.66, 2.6,   // At 0.66 time, value of 2.6
   *     1, 3         // At 1 time, value of 3
   * ]);
   */
  constructor(data) {
    this.keys = [];
    /**
     * The curve interpolation scheme. Can be:
     *
     * - {@link CURVE_LINEAR}
     * - {@link CURVE_SMOOTHSTEP}
     * - {@link CURVE_SPLINE}
     * - {@link CURVE_STEP}
     *
     * Defaults to {@link CURVE_SMOOTHSTEP}.
     *
     * @type {number}
     */
    this.type = CURVE_SMOOTHSTEP;
    /**
     * Controls how {@link CURVE_SPLINE} tangents are calculated. Valid range is between 0 and 1
     * where 0 results in a non-smooth curve (equivalent to linear interpolation) and 1 results in
     * a very smooth curve. Use 0.5 for a Catmull-rom spline.
     *
     * @type {number}
     */
    this.tension = 0.5;
    /**
     * @type {CurveEvaluator}
     * @private
     */
    this._eval = new CurveEvaluator(this);
    if (data) {
      for (let i = 0; i < data.length - 1; i += 2) {
        this.keys.push([data[i], data[i + 1]]);
      }
    }
    this.sort();
  }

  /**
   * Get the number of keys in the curve.
   *
   * @type {number}
   */
  get length() {
    return this.keys.length;
  }

  /**
   * Add a new key to the curve.
   *
   * @param {number} time - Time to add new key.
   * @param {number} value - Value of new key.
   * @returns {number[]} [time, value] pair.
   */
  add(time, value) {
    const keys = this.keys;
    const len = keys.length;
    let i = 0;
    for (; i < len; i++) {
      if (keys[i][0] > time) {
        break;
      }
    }
    const key = [time, value];
    this.keys.splice(i, 0, key);
    return key;
  }

  /**
   * Return a specific key.
   *
   * @param {number} index - The index of the key to return.
   * @returns {number[]} The key at the specified index.
   */
  get(index) {
    return this.keys[index];
  }

  /**
   * Sort keys by time.
   */
  sort() {
    this.keys.sort(function (a, b) {
      return a[0] - b[0];
    });
  }

  /**
   * Returns the interpolated value of the curve at specified time.
   *
   * @param {number} time - The time at which to calculate the value.
   * @returns {number} The interpolated value.
   */
  value(time) {
    // we force reset the evaluation because keys may have changed since the last evaluate
    // (we can't know)
    return this._eval.evaluate(time, true);
  }
  closest(time) {
    const keys = this.keys;
    const length = keys.length;
    let min = 2;
    let result = null;
    for (let i = 0; i < length; i++) {
      const diff = Math.abs(time - keys[i][0]);
      if (min >= diff) {
        min = diff;
        result = keys[i];
      } else {
        break;
      }
    }
    return result;
  }

  /**
   * Returns a clone of the specified curve object.
   *
   * @returns {this} A clone of the specified curve.
   */
  clone() {
    /** @type {this} */
    const result = new this.constructor();
    result.keys = extend(result.keys, this.keys);
    result.type = this.type;
    result.tension = this.tension;
    return result;
  }

  /**
   * Sample the curve at regular intervals over the range [0..1].
   *
   * @param {number} precision - The number of samples to return.
   * @returns {Float32Array} The set of quantized values.
   * @ignore
   */
  quantize(precision) {
    precision = Math.max(precision, 2);
    const values = new Float32Array(precision);
    const step = 1.0 / (precision - 1);

    // quantize graph to table of interpolated values
    values[0] = this._eval.evaluate(0, true);
    for (let i = 1; i < precision; i++) {
      values[i] = this._eval.evaluate(step * i);
    }
    return values;
  }

  /**
   * Sample the curve at regular intervals over the range [0..1] and clamp the resulting samples
   * to [min..max].
   *
   * @param {number} precision - The number of samples to return.
   * @param {number} min - The minimum output value.
   * @param {number} max - The maximum output value.
   * @returns {Float32Array} The set of quantized values.
   * @ignore
   */
  quantizeClamped(precision, min, max) {
    const result = this.quantize(precision);
    for (let i = 0; i < result.length; ++i) {
      result[i] = Math.min(max, Math.max(min, result[i]));
    }
    return result;
  }
}

export { Curve };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VydmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9jb3JlL21hdGgvY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vY29yZS5qcyc7XG5cbmltcG9ydCB7IENVUlZFX1NNT09USFNURVAgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBDdXJ2ZUV2YWx1YXRvciB9IGZyb20gJy4vY3VydmUtZXZhbHVhdG9yLmpzJztcblxuLyoqXG4gKiBBIGN1cnZlIGlzIGEgY29sbGVjdGlvbiBvZiBrZXlzICh0aW1lL3ZhbHVlIHBhaXJzKS4gVGhlIHNoYXBlIG9mIHRoZSBjdXJ2ZSBpcyBkZWZpbmVkIGJ5IGl0c1xuICogdHlwZSB0aGF0IHNwZWNpZmllcyBhbiBpbnRlcnBvbGF0aW9uIHNjaGVtZSBmb3IgdGhlIGtleXMuXG4gKlxuICogQGNhdGVnb3J5IE1hdGhcbiAqL1xuY2xhc3MgQ3VydmUge1xuICAgIGtleXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJ2ZSBpbnRlcnBvbGF0aW9uIHNjaGVtZS4gQ2FuIGJlOlxuICAgICAqXG4gICAgICogLSB7QGxpbmsgQ1VSVkVfTElORUFSfVxuICAgICAqIC0ge0BsaW5rIENVUlZFX1NNT09USFNURVB9XG4gICAgICogLSB7QGxpbmsgQ1VSVkVfU1BMSU5FfVxuICAgICAqIC0ge0BsaW5rIENVUlZFX1NURVB9XG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byB7QGxpbmsgQ1VSVkVfU01PT1RIU1RFUH0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHR5cGUgPSBDVVJWRV9TTU9PVEhTVEVQO1xuXG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgaG93IHtAbGluayBDVVJWRV9TUExJTkV9IHRhbmdlbnRzIGFyZSBjYWxjdWxhdGVkLiBWYWxpZCByYW5nZSBpcyBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiB3aGVyZSAwIHJlc3VsdHMgaW4gYSBub24tc21vb3RoIGN1cnZlIChlcXVpdmFsZW50IHRvIGxpbmVhciBpbnRlcnBvbGF0aW9uKSBhbmQgMSByZXN1bHRzIGluXG4gICAgICogYSB2ZXJ5IHNtb290aCBjdXJ2ZS4gVXNlIDAuNSBmb3IgYSBDYXRtdWxsLXJvbSBzcGxpbmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRlbnNpb24gPSAwLjU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q3VydmVFdmFsdWF0b3J9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXZhbCA9IG5ldyBDdXJ2ZUV2YWx1YXRvcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ3VydmUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBbZGF0YV0gLSBBbiBhcnJheSBvZiBrZXlzIChwYWlycyBvZiBudW1iZXJzIHdpdGggdGhlIHRpbWUgZmlyc3QgYW5kIHZhbHVlXG4gICAgICogc2Vjb25kKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGN1cnZlID0gbmV3IHBjLkN1cnZlKFtcbiAgICAgKiAgICAgMCwgMCwgICAgICAgIC8vIEF0IDAgdGltZSwgdmFsdWUgb2YgMFxuICAgICAqICAgICAwLjMzLCAyLCAgICAgLy8gQXQgMC4zMyB0aW1lLCB2YWx1ZSBvZiAyXG4gICAgICogICAgIDAuNjYsIDIuNiwgICAvLyBBdCAwLjY2IHRpbWUsIHZhbHVlIG9mIDIuNlxuICAgICAqICAgICAxLCAzICAgICAgICAgLy8gQXQgMSB0aW1lLCB2YWx1ZSBvZiAzXG4gICAgICogXSk7XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKFtkYXRhW2ldLCBkYXRhW2kgKyAxXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2Yga2V5cyBpbiB0aGUgY3VydmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBrZXkgdG8gdGhlIGN1cnZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBUaW1lIHRvIGFkZCBuZXcga2V5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIG9mIG5ldyBrZXkuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBbdGltZSwgdmFsdWVdIHBhaXIuXG4gICAgICovXG4gICAgYWRkKHRpbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmtleXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBsZXQgaSA9IDA7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGtleXNbaV1bMF0gPiB0aW1lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXkgPSBbdGltZSwgdmFsdWVdO1xuICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGksIDAsIGtleSk7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3BlY2lmaWMga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBrZXkgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gVGhlIGtleSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTb3J0IGtleXMgYnkgdGltZS5cbiAgICAgKi9cbiAgICBzb3J0KCkge1xuICAgICAgICB0aGlzLmtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgb2YgdGhlIGN1cnZlIGF0IHNwZWNpZmllZCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBUaGUgdGltZSBhdCB3aGljaCB0byBjYWxjdWxhdGUgdGhlIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWUodGltZSkge1xuICAgICAgICAvLyB3ZSBmb3JjZSByZXNldCB0aGUgZXZhbHVhdGlvbiBiZWNhdXNlIGtleXMgbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBldmFsdWF0ZVxuICAgICAgICAvLyAod2UgY2FuJ3Qga25vdylcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWwuZXZhbHVhdGUodGltZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY2xvc2VzdCh0aW1lKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmtleXM7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBsZXQgbWluID0gMjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHRpbWUgLSBrZXlzW2ldWzBdKTtcbiAgICAgICAgICAgIGlmIChtaW4gPj0gZGlmZikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGRpZmY7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgc3BlY2lmaWVkIGN1cnZlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt0aGlzfSBBIGNsb25lIG9mIHRoZSBzcGVjaWZpZWQgY3VydmUuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7dGhpc30gKi9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgcmVzdWx0LmtleXMgPSBleHRlbmQocmVzdWx0LmtleXMsIHRoaXMua2V5cyk7XG4gICAgICAgIHJlc3VsdC50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICByZXN1bHQudGVuc2lvbiA9IHRoaXMudGVuc2lvbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGUgdGhlIGN1cnZlIGF0IHJlZ3VsYXIgaW50ZXJ2YWxzIG92ZXIgdGhlIHJhbmdlIFswLi4xXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gLSBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBzZXQgb2YgcXVhbnRpemVkIHZhbHVlcy5cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcXVhbnRpemUocHJlY2lzaW9uKSB7XG4gICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KHByZWNpc2lvbiwgMik7XG5cbiAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShwcmVjaXNpb24pO1xuICAgICAgICBjb25zdCBzdGVwID0gMS4wIC8gKHByZWNpc2lvbiAtIDEpO1xuXG4gICAgICAgIC8vIHF1YW50aXplIGdyYXBoIHRvIHRhYmxlIG9mIGludGVycG9sYXRlZCB2YWx1ZXNcbiAgICAgICAgdmFsdWVzWzBdID0gdGhpcy5fZXZhbC5ldmFsdWF0ZSgwLCB0cnVlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcmVjaXNpb247IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gdGhpcy5fZXZhbC5ldmFsdWF0ZShzdGVwICogaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbXBsZSB0aGUgY3VydmUgYXQgcmVndWxhciBpbnRlcnZhbHMgb3ZlciB0aGUgcmFuZ2UgWzAuLjFdIGFuZCBjbGFtcCB0aGUgcmVzdWx0aW5nIHNhbXBsZXNcbiAgICAgKiB0byBbbWluLi5tYXhdLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIG91dHB1dCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gb3V0cHV0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBzZXQgb2YgcXVhbnRpemVkIHZhbHVlcy5cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcXVhbnRpemVDbGFtcGVkKHByZWNpc2lvbiwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5xdWFudGl6ZShwcmVjaXNpb24pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHJlc3VsdFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgeyBDdXJ2ZSB9O1xuIl0sIm5hbWVzIjpbIkN1cnZlIiwiY29uc3RydWN0b3IiLCJkYXRhIiwia2V5cyIsInR5cGUiLCJDVVJWRV9TTU9PVEhTVEVQIiwidGVuc2lvbiIsIl9ldmFsIiwiQ3VydmVFdmFsdWF0b3IiLCJpIiwibGVuZ3RoIiwicHVzaCIsInNvcnQiLCJhZGQiLCJ0aW1lIiwidmFsdWUiLCJsZW4iLCJrZXkiLCJzcGxpY2UiLCJnZXQiLCJpbmRleCIsImEiLCJiIiwiZXZhbHVhdGUiLCJjbG9zZXN0IiwibWluIiwicmVzdWx0IiwiZGlmZiIsIk1hdGgiLCJhYnMiLCJjbG9uZSIsImV4dGVuZCIsInF1YW50aXplIiwicHJlY2lzaW9uIiwibWF4IiwidmFsdWVzIiwiRmxvYXQzMkFycmF5Iiwic3RlcCIsInF1YW50aXplQ2xhbXBlZCJdLCJtYXBwaW5ncyI6Ijs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLEtBQUssQ0FBQztBQWdDUjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxXQUFXQSxDQUFDQyxJQUFJLEVBQUU7SUFBQSxJQTVDbEJDLENBQUFBLElBQUksR0FBRyxFQUFFLENBQUE7QUFFVDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFYSSxJQVlBQyxDQUFBQSxJQUFJLEdBQUdDLGdCQUFnQixDQUFBO0FBRXZCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBTkksSUFPQUMsQ0FBQUEsT0FBTyxHQUFHLEdBQUcsQ0FBQTtBQUViO0FBQ0o7QUFDQTtBQUNBO0FBSEksSUFBQSxJQUFBLENBSUFDLEtBQUssR0FBRyxJQUFJQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUE7QUFnQjVCLElBQUEsSUFBSU4sSUFBSSxFQUFFO0FBQ04sTUFBQSxLQUFLLElBQUlPLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR1AsSUFBSSxDQUFDUSxNQUFNLEdBQUcsQ0FBQyxFQUFFRCxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3pDLFFBQUEsSUFBSSxDQUFDTixJQUFJLENBQUNRLElBQUksQ0FBQyxDQUFDVCxJQUFJLENBQUNPLENBQUMsQ0FBQyxFQUFFUCxJQUFJLENBQUNPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDMUMsT0FBQTtBQUNKLEtBQUE7SUFFQSxJQUFJLENBQUNHLElBQUksRUFBRSxDQUFBO0FBQ2YsR0FBQTs7QUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSUYsTUFBTUEsR0FBRztBQUNULElBQUEsT0FBTyxJQUFJLENBQUNQLElBQUksQ0FBQ08sTUFBTSxDQUFBO0FBQzNCLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUcsRUFBQUEsR0FBR0EsQ0FBQ0MsSUFBSSxFQUFFQyxLQUFLLEVBQUU7QUFDYixJQUFBLE1BQU1aLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQTtBQUN0QixJQUFBLE1BQU1hLEdBQUcsR0FBR2IsSUFBSSxDQUFDTyxNQUFNLENBQUE7SUFDdkIsSUFBSUQsQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUVULElBQUEsT0FBT0EsQ0FBQyxHQUFHTyxHQUFHLEVBQUVQLENBQUMsRUFBRSxFQUFFO01BQ2pCLElBQUlOLElBQUksQ0FBQ00sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUdLLElBQUksRUFBRTtBQUNuQixRQUFBLE1BQUE7QUFDSixPQUFBO0FBQ0osS0FBQTtBQUVBLElBQUEsTUFBTUcsR0FBRyxHQUFHLENBQUNILElBQUksRUFBRUMsS0FBSyxDQUFDLENBQUE7SUFDekIsSUFBSSxDQUFDWixJQUFJLENBQUNlLE1BQU0sQ0FBQ1QsQ0FBQyxFQUFFLENBQUMsRUFBRVEsR0FBRyxDQUFDLENBQUE7QUFDM0IsSUFBQSxPQUFPQSxHQUFHLENBQUE7QUFDZCxHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJRSxHQUFHQSxDQUFDQyxLQUFLLEVBQUU7QUFDUCxJQUFBLE9BQU8sSUFBSSxDQUFDakIsSUFBSSxDQUFDaUIsS0FBSyxDQUFDLENBQUE7QUFDM0IsR0FBQTs7QUFFQTtBQUNKO0FBQ0E7QUFDSVIsRUFBQUEsSUFBSUEsR0FBRztJQUNILElBQUksQ0FBQ1QsSUFBSSxDQUFDUyxJQUFJLENBQUMsVUFBVVMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7TUFDM0IsT0FBT0QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDdEIsS0FBQyxDQUFDLENBQUE7QUFDTixHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJUCxLQUFLQSxDQUFDRCxJQUFJLEVBQUU7QUFDUjtBQUNBO0lBQ0EsT0FBTyxJQUFJLENBQUNQLEtBQUssQ0FBQ2dCLFFBQVEsQ0FBQ1QsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO0FBQzFDLEdBQUE7RUFFQVUsT0FBT0EsQ0FBQ1YsSUFBSSxFQUFFO0FBQ1YsSUFBQSxNQUFNWCxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUE7QUFDdEIsSUFBQSxNQUFNTyxNQUFNLEdBQUdQLElBQUksQ0FBQ08sTUFBTSxDQUFBO0lBQzFCLElBQUllLEdBQUcsR0FBRyxDQUFDLENBQUE7SUFDWCxJQUFJQyxNQUFNLEdBQUcsSUFBSSxDQUFBO0lBRWpCLEtBQUssSUFBSWpCLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0MsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtBQUM3QixNQUFBLE1BQU1rQixJQUFJLEdBQUdDLElBQUksQ0FBQ0MsR0FBRyxDQUFDZixJQUFJLEdBQUdYLElBQUksQ0FBQ00sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtNQUN4QyxJQUFJZ0IsR0FBRyxJQUFJRSxJQUFJLEVBQUU7QUFDYkYsUUFBQUEsR0FBRyxHQUFHRSxJQUFJLENBQUE7QUFDVkQsUUFBQUEsTUFBTSxHQUFHdkIsSUFBSSxDQUFDTSxDQUFDLENBQUMsQ0FBQTtBQUNwQixPQUFDLE1BQU07QUFDSCxRQUFBLE1BQUE7QUFDSixPQUFBO0FBQ0osS0FBQTtBQUVBLElBQUEsT0FBT2lCLE1BQU0sQ0FBQTtBQUNqQixHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDSUksRUFBQUEsS0FBS0EsR0FBRztBQUNKO0FBQ0EsSUFBQSxNQUFNSixNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUN6QixXQUFXLEVBQUUsQ0FBQTtBQUNyQ3lCLElBQUFBLE1BQU0sQ0FBQ3ZCLElBQUksR0FBRzRCLE1BQU0sQ0FBQ0wsTUFBTSxDQUFDdkIsSUFBSSxFQUFFLElBQUksQ0FBQ0EsSUFBSSxDQUFDLENBQUE7QUFDNUN1QixJQUFBQSxNQUFNLENBQUN0QixJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUE7QUFDdkJzQixJQUFBQSxNQUFNLENBQUNwQixPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUE7QUFDN0IsSUFBQSxPQUFPb0IsTUFBTSxDQUFBO0FBQ2pCLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSU0sUUFBUUEsQ0FBQ0MsU0FBUyxFQUFFO0lBQ2hCQSxTQUFTLEdBQUdMLElBQUksQ0FBQ00sR0FBRyxDQUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUE7QUFFbEMsSUFBQSxNQUFNRSxNQUFNLEdBQUcsSUFBSUMsWUFBWSxDQUFDSCxTQUFTLENBQUMsQ0FBQTtBQUMxQyxJQUFBLE1BQU1JLElBQUksR0FBRyxHQUFHLElBQUlKLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQTs7QUFFbEM7QUFDQUUsSUFBQUEsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQzVCLEtBQUssQ0FBQ2dCLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUE7SUFDeEMsS0FBSyxJQUFJZCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd3QixTQUFTLEVBQUV4QixDQUFDLEVBQUUsRUFBRTtBQUNoQzBCLE1BQUFBLE1BQU0sQ0FBQzFCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ0YsS0FBSyxDQUFDZ0IsUUFBUSxDQUFDYyxJQUFJLEdBQUc1QixDQUFDLENBQUMsQ0FBQTtBQUM3QyxLQUFBO0FBRUEsSUFBQSxPQUFPMEIsTUFBTSxDQUFBO0FBQ2pCLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUcsRUFBQUEsZUFBZUEsQ0FBQ0wsU0FBUyxFQUFFUixHQUFHLEVBQUVTLEdBQUcsRUFBRTtBQUNqQyxJQUFBLE1BQU1SLE1BQU0sR0FBRyxJQUFJLENBQUNNLFFBQVEsQ0FBQ0MsU0FBUyxDQUFDLENBQUE7QUFDdkMsSUFBQSxLQUFLLElBQUl4QixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdpQixNQUFNLENBQUNoQixNQUFNLEVBQUUsRUFBRUQsQ0FBQyxFQUFFO01BQ3BDaUIsTUFBTSxDQUFDakIsQ0FBQyxDQUFDLEdBQUdtQixJQUFJLENBQUNILEdBQUcsQ0FBQ1MsR0FBRyxFQUFFTixJQUFJLENBQUNNLEdBQUcsQ0FBQ1QsR0FBRyxFQUFFQyxNQUFNLENBQUNqQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDdkQsS0FBQTtBQUNBLElBQUEsT0FBT2lCLE1BQU0sQ0FBQTtBQUNqQixHQUFBO0FBQ0o7Ozs7In0=
