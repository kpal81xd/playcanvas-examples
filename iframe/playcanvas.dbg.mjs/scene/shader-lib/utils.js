import { extends as _extends } from '../../_virtual/_rollupPluginBabelHelpers.js';
import { Shader } from '../../platform/graphics/shader.js';
import { ShaderUtils } from '../../platform/graphics/shader-utils.js';
import { shaderChunks } from './chunks/chunks.js';
import { getProgramLibrary } from './get-program-library.js';
import { Debug } from '../../core/debug.js';
import { ShaderGenerator } from './programs/shader-generator.js';

/**
 * Create a shader from named shader chunks.
 *
 * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} device - The
 * graphics device.
 * @param {string} vsName - The vertex shader chunk name.
 * @param {string} fsName - The fragment shader chunk name.
 * @param {boolean | Record<string, boolean | string | string[]>} [useTransformFeedback] - Whether
 * to use transform feedback. Defaults to false.
 * @param {object} [shaderDefinitionOptions] - Additional options that will be added to the shader
 * definition.
 * @param {boolean} [shaderDefinitionOptions.useTransformFeedback] - Whether to use transform
 * feedback. Defaults to false.
 * @param {string | string[]} [shaderDefinitionOptions.fragmentOutputTypes] - Fragment shader
 * output types, which default to vec4. Passing a string will set the output type for all color
 * attachments. Passing an array will set the output type for each color attachment.
 * @see ShaderUtils.createDefinition
 * @returns {Shader} The newly created shader.
 * @category Graphics
 */
function createShader(device, vsName, fsName, useTransformFeedback = false, shaderDefinitionOptions = {}) {
  // Normalize arguments to allow passing shaderDefinitionOptions as the 6th argument
  if (typeof useTransformFeedback === 'boolean') {
    shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
  } else if (typeof useTransformFeedback === 'object') {
    shaderDefinitionOptions = _extends({}, shaderDefinitionOptions, useTransformFeedback);
  }
  return new Shader(device, ShaderUtils.createDefinition(device, _extends({}, shaderDefinitionOptions, {
    name: `${vsName}_${fsName}`,
    vertexCode: shaderChunks[vsName],
    fragmentCode: shaderChunks[fsName]
  })));
}

/**
 * Create a shader from the supplied source code. Note that this function adds additional shader
 * blocks to both vertex and fragment shaders, which allow the shader to use more features and
 * compile on both WebGL and WebGPU. Specifically, these blocks are added, and should not be
 * part of provided vsCode and fsCode: shader version, shader precision, commonly used extensions.
 *
 * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} device - The
 * graphics device.
 * @param {string} vsCode - The vertex shader code.
 * @param {string} fsCode - The fragment shader code.
 * @param {string} uniqueName - Unique name for the shader. If a shader with this name already
 * exists, it will be returned instead of a new shader instance.
 * @param {Object<string, string>} [attributes] - Object detailing the mapping of vertex shader
 * attribute names to semantics SEMANTIC_*. This enables the engine to match vertex buffer data as
 * inputs to the shader. Defaults to undefined, which generates the default attributes.
 * @param {boolean | Record<string, boolean | string | string[]>} [useTransformFeedback] - Whether
 * to use transform feedback. Defaults to false.
 * @param {object} [shaderDefinitionOptions] - Additional options that will be added to the shader
 * definition.
 * @param {boolean} [shaderDefinitionOptions.useTransformFeedback] - Whether to use transform
 * feedback. Defaults to false.
 * @param {string | string[]} [shaderDefinitionOptions.fragmentOutputTypes] - Fragment shader
 * output types, which default to vec4. Passing a string will set the output type for all color
 * attachments. Passing an array will set the output type for each color attachment.
 * @see ShaderUtils.createDefinition
 * @returns {Shader} The newly created shader.
 * @category Graphics
 */
function createShaderFromCode(device, vsCode, fsCode, uniqueName, attributes, useTransformFeedback = false, shaderDefinitionOptions = {}) {
  // the function signature has changed, fail if called incorrectly
  Debug.assert(typeof attributes !== 'boolean');

  // Normalize arguments to allow passing shaderDefinitionOptions as the 6th argument
  if (typeof useTransformFeedback === 'boolean') {
    shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
  } else if (typeof useTransformFeedback === 'object') {
    shaderDefinitionOptions = _extends({}, shaderDefinitionOptions, useTransformFeedback);
  }
  const programLibrary = getProgramLibrary(device);
  let shader = programLibrary.getCachedShader(uniqueName);
  if (!shader) {
    shader = new Shader(device, ShaderUtils.createDefinition(device, _extends({}, shaderDefinitionOptions, {
      name: uniqueName,
      vertexCode: vsCode,
      fragmentCode: fsCode,
      attributes: attributes
    })));
    programLibrary.setCachedShader(uniqueName, shader);
  }
  return shader;
}
class ShaderGeneratorPassThrough extends ShaderGenerator {
  constructor(key, shaderDefinition) {
    super();
    this.key = key;
    this.shaderDefinition = shaderDefinition;
  }
  generateKey(options) {
    return this.key;
  }
  createShaderDefinition(device, options) {
    return this.shaderDefinition;
  }
}

/**
 * Process shader using shader processing options, utilizing cache of the ProgramLibrary
 *
 * @param {Shader} shader - The shader to be processed.
 * @param {import('../../platform/graphics/shader-processor-options.js').ShaderProcessorOptions} processingOptions -
 * The shader processing options.
 * @returns {Shader} The processed shader.
 * @ignore
 */
function processShader(shader, processingOptions) {
  var _shaderDefinition$nam;
  Debug.assert(shader);
  const shaderDefinition = shader.definition;

  // 'shader' generator for a material - simply return existing shader definition. Use generator and getProgram
  // to allow for shader processing to be cached
  const name = (_shaderDefinition$nam = shaderDefinition.name) != null ? _shaderDefinition$nam : 'shader';

  // unique name based of the shader id
  const key = `${name}-id-${shader.id}`;
  const materialGenerator = new ShaderGeneratorPassThrough(key, shaderDefinition);

  // temporarily register the program generator
  const libraryModuleName = 'shader';
  const library = getProgramLibrary(shader.device);
  Debug.assert(!library.isRegistered(libraryModuleName));
  library.register(libraryModuleName, materialGenerator);

  // generate shader variant - its the same shader, but with different processing options
  const variant = library.getProgram(libraryModuleName, {}, processingOptions);

  // unregister it again
  library.unregister(libraryModuleName);
  return variant;
}
shaderChunks.createShader = createShader;
shaderChunks.createShaderFromCode = createShaderFromCode;

export { createShader, createShaderFromCode, processShader };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9zY2VuZS9zaGFkZXItbGliL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci5qcyc7XG5pbXBvcnQgeyBTaGFkZXJVdGlscyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci11dGlscy5qcyc7XG5pbXBvcnQgeyBzaGFkZXJDaHVua3MgfSBmcm9tICcuL2NodW5rcy9jaHVua3MuanMnO1xuaW1wb3J0IHsgZ2V0UHJvZ3JhbUxpYnJhcnkgfSBmcm9tICcuL2dldC1wcm9ncmFtLWxpYnJhcnkuanMnO1xuaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IFNoYWRlckdlbmVyYXRvciB9IGZyb20gJy4vcHJvZ3JhbXMvc2hhZGVyLWdlbmVyYXRvci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGEgc2hhZGVyIGZyb20gbmFtZWQgc2hhZGVyIGNodW5rcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvZ3JhcGhpY3MtZGV2aWNlLmpzJykuR3JhcGhpY3NEZXZpY2V9IGRldmljZSAtIFRoZVxuICogZ3JhcGhpY3MgZGV2aWNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHZzTmFtZSAtIFRoZSB2ZXJ0ZXggc2hhZGVyIGNodW5rIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnNOYW1lIC0gVGhlIGZyYWdtZW50IHNoYWRlciBjaHVuayBuYW1lLlxuICogQHBhcmFtIHtib29sZWFuIHwgUmVjb3JkPHN0cmluZywgYm9vbGVhbiB8IHN0cmluZyB8IHN0cmluZ1tdPn0gW3VzZVRyYW5zZm9ybUZlZWRiYWNrXSAtIFdoZXRoZXJcbiAqIHRvIHVzZSB0cmFuc2Zvcm0gZmVlZGJhY2suIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHBhcmFtIHtvYmplY3R9IFtzaGFkZXJEZWZpbml0aW9uT3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaGFkZXJcbiAqIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaGFkZXJEZWZpbml0aW9uT3B0aW9ucy51c2VUcmFuc2Zvcm1GZWVkYmFja10gLSBXaGV0aGVyIHRvIHVzZSB0cmFuc2Zvcm1cbiAqIGZlZWRiYWNrLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IFtzaGFkZXJEZWZpbml0aW9uT3B0aW9ucy5mcmFnbWVudE91dHB1dFR5cGVzXSAtIEZyYWdtZW50IHNoYWRlclxuICogb3V0cHV0IHR5cGVzLCB3aGljaCBkZWZhdWx0IHRvIHZlYzQuIFBhc3NpbmcgYSBzdHJpbmcgd2lsbCBzZXQgdGhlIG91dHB1dCB0eXBlIGZvciBhbGwgY29sb3JcbiAqIGF0dGFjaG1lbnRzLiBQYXNzaW5nIGFuIGFycmF5IHdpbGwgc2V0IHRoZSBvdXRwdXQgdHlwZSBmb3IgZWFjaCBjb2xvciBhdHRhY2htZW50LlxuICogQHNlZSBTaGFkZXJVdGlscy5jcmVhdGVEZWZpbml0aW9uXG4gKiBAcmV0dXJucyB7U2hhZGVyfSBUaGUgbmV3bHkgY3JlYXRlZCBzaGFkZXIuXG4gKiBAY2F0ZWdvcnkgR3JhcGhpY3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGRldmljZSwgdnNOYW1lLCBmc05hbWUsIHVzZVRyYW5zZm9ybUZlZWRiYWNrID0gZmFsc2UsIHNoYWRlckRlZmluaXRpb25PcHRpb25zID0ge30pIHtcblxuICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHMgdG8gYWxsb3cgcGFzc2luZyBzaGFkZXJEZWZpbml0aW9uT3B0aW9ucyBhcyB0aGUgNnRoIGFyZ3VtZW50XG4gICAgaWYgKHR5cGVvZiB1c2VUcmFuc2Zvcm1GZWVkYmFjayA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHNoYWRlckRlZmluaXRpb25PcHRpb25zLnVzZVRyYW5zZm9ybUZlZWRiYWNrID0gdXNlVHJhbnNmb3JtRmVlZGJhY2s7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdXNlVHJhbnNmb3JtRmVlZGJhY2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHNoYWRlckRlZmluaXRpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgLi4uc2hhZGVyRGVmaW5pdGlvbk9wdGlvbnMsXG4gICAgICAgICAgICAuLi51c2VUcmFuc2Zvcm1GZWVkYmFja1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2hhZGVyKGRldmljZSwgU2hhZGVyVXRpbHMuY3JlYXRlRGVmaW5pdGlvbihkZXZpY2UsIHtcbiAgICAgICAgLi4uc2hhZGVyRGVmaW5pdGlvbk9wdGlvbnMsXG4gICAgICAgIG5hbWU6IGAke3ZzTmFtZX1fJHtmc05hbWV9YCxcbiAgICAgICAgdmVydGV4Q29kZTogc2hhZGVyQ2h1bmtzW3ZzTmFtZV0sXG4gICAgICAgIGZyYWdtZW50Q29kZTogc2hhZGVyQ2h1bmtzW2ZzTmFtZV1cbiAgICB9KSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2hhZGVyIGZyb20gdGhlIHN1cHBsaWVkIHNvdXJjZSBjb2RlLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhZGRzIGFkZGl0aW9uYWwgc2hhZGVyXG4gKiBibG9ja3MgdG8gYm90aCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMsIHdoaWNoIGFsbG93IHRoZSBzaGFkZXIgdG8gdXNlIG1vcmUgZmVhdHVyZXMgYW5kXG4gKiBjb21waWxlIG9uIGJvdGggV2ViR0wgYW5kIFdlYkdQVS4gU3BlY2lmaWNhbGx5LCB0aGVzZSBibG9ja3MgYXJlIGFkZGVkLCBhbmQgc2hvdWxkIG5vdCBiZVxuICogcGFydCBvZiBwcm92aWRlZCB2c0NvZGUgYW5kIGZzQ29kZTogc2hhZGVyIHZlcnNpb24sIHNoYWRlciBwcmVjaXNpb24sIGNvbW1vbmx5IHVzZWQgZXh0ZW5zaW9ucy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvZ3JhcGhpY3MtZGV2aWNlLmpzJykuR3JhcGhpY3NEZXZpY2V9IGRldmljZSAtIFRoZVxuICogZ3JhcGhpY3MgZGV2aWNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHZzQ29kZSAtIFRoZSB2ZXJ0ZXggc2hhZGVyIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnNDb2RlIC0gVGhlIGZyYWdtZW50IHNoYWRlciBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHVuaXF1ZU5hbWUgLSBVbmlxdWUgbmFtZSBmb3IgdGhlIHNoYWRlci4gSWYgYSBzaGFkZXIgd2l0aCB0aGlzIG5hbWUgYWxyZWFkeVxuICogZXhpc3RzLCBpdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYSBuZXcgc2hhZGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbYXR0cmlidXRlc10gLSBPYmplY3QgZGV0YWlsaW5nIHRoZSBtYXBwaW5nIG9mIHZlcnRleCBzaGFkZXJcbiAqIGF0dHJpYnV0ZSBuYW1lcyB0byBzZW1hbnRpY3MgU0VNQU5USUNfKi4gVGhpcyBlbmFibGVzIHRoZSBlbmdpbmUgdG8gbWF0Y2ggdmVydGV4IGJ1ZmZlciBkYXRhIGFzXG4gKiBpbnB1dHMgdG8gdGhlIHNoYWRlci4gRGVmYXVsdHMgdG8gdW5kZWZpbmVkLCB3aGljaCBnZW5lcmF0ZXMgdGhlIGRlZmF1bHQgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4gfCBzdHJpbmcgfCBzdHJpbmdbXT59IFt1c2VUcmFuc2Zvcm1GZWVkYmFja10gLSBXaGV0aGVyXG4gKiB0byB1c2UgdHJhbnNmb3JtIGZlZWRiYWNrLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2hhZGVyRGVmaW5pdGlvbk9wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2hhZGVyXG4gKiBkZWZpbml0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbc2hhZGVyRGVmaW5pdGlvbk9wdGlvbnMudXNlVHJhbnNmb3JtRmVlZGJhY2tdIC0gV2hldGhlciB0byB1c2UgdHJhbnNmb3JtXG4gKiBmZWVkYmFjay4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBbc2hhZGVyRGVmaW5pdGlvbk9wdGlvbnMuZnJhZ21lbnRPdXRwdXRUeXBlc10gLSBGcmFnbWVudCBzaGFkZXJcbiAqIG91dHB1dCB0eXBlcywgd2hpY2ggZGVmYXVsdCB0byB2ZWM0LiBQYXNzaW5nIGEgc3RyaW5nIHdpbGwgc2V0IHRoZSBvdXRwdXQgdHlwZSBmb3IgYWxsIGNvbG9yXG4gKiBhdHRhY2htZW50cy4gUGFzc2luZyBhbiBhcnJheSB3aWxsIHNldCB0aGUgb3V0cHV0IHR5cGUgZm9yIGVhY2ggY29sb3IgYXR0YWNobWVudC5cbiAqIEBzZWUgU2hhZGVyVXRpbHMuY3JlYXRlRGVmaW5pdGlvblxuICogQHJldHVybnMge1NoYWRlcn0gVGhlIG5ld2x5IGNyZWF0ZWQgc2hhZGVyLlxuICogQGNhdGVnb3J5IEdyYXBoaWNzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNoYWRlckZyb21Db2RlKGRldmljZSwgdnNDb2RlLCBmc0NvZGUsIHVuaXF1ZU5hbWUsIGF0dHJpYnV0ZXMsIHVzZVRyYW5zZm9ybUZlZWRiYWNrID0gZmFsc2UsIHNoYWRlckRlZmluaXRpb25PcHRpb25zID0ge30pIHtcblxuICAgIC8vIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQsIGZhaWwgaWYgY2FsbGVkIGluY29ycmVjdGx5XG4gICAgRGVidWcuYXNzZXJ0KHR5cGVvZiBhdHRyaWJ1dGVzICE9PSAnYm9vbGVhbicpO1xuXG4gICAgLy8gTm9ybWFsaXplIGFyZ3VtZW50cyB0byBhbGxvdyBwYXNzaW5nIHNoYWRlckRlZmluaXRpb25PcHRpb25zIGFzIHRoZSA2dGggYXJndW1lbnRcbiAgICBpZiAodHlwZW9mIHVzZVRyYW5zZm9ybUZlZWRiYWNrID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgc2hhZGVyRGVmaW5pdGlvbk9wdGlvbnMudXNlVHJhbnNmb3JtRmVlZGJhY2sgPSB1c2VUcmFuc2Zvcm1GZWVkYmFjaztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB1c2VUcmFuc2Zvcm1GZWVkYmFjayA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2hhZGVyRGVmaW5pdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5zaGFkZXJEZWZpbml0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnVzZVRyYW5zZm9ybUZlZWRiYWNrXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZ3JhbUxpYnJhcnkgPSBnZXRQcm9ncmFtTGlicmFyeShkZXZpY2UpO1xuICAgIGxldCBzaGFkZXIgPSBwcm9ncmFtTGlicmFyeS5nZXRDYWNoZWRTaGFkZXIodW5pcXVlTmFtZSk7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgICAgc2hhZGVyID0gbmV3IFNoYWRlcihkZXZpY2UsIFNoYWRlclV0aWxzLmNyZWF0ZURlZmluaXRpb24oZGV2aWNlLCB7XG4gICAgICAgICAgICAuLi5zaGFkZXJEZWZpbml0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgIG5hbWU6IHVuaXF1ZU5hbWUsXG4gICAgICAgICAgICB2ZXJ0ZXhDb2RlOiB2c0NvZGUsXG4gICAgICAgICAgICBmcmFnbWVudENvZGU6IGZzQ29kZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgICAgICAgfSkpO1xuICAgICAgICBwcm9ncmFtTGlicmFyeS5zZXRDYWNoZWRTaGFkZXIodW5pcXVlTmFtZSwgc2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbn1cblxuY2xhc3MgU2hhZGVyR2VuZXJhdG9yUGFzc1Rocm91Z2ggZXh0ZW5kcyBTaGFkZXJHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGtleSwgc2hhZGVyRGVmaW5pdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zaGFkZXJEZWZpbml0aW9uID0gc2hhZGVyRGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZUtleShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG5cbiAgICBjcmVhdGVTaGFkZXJEZWZpbml0aW9uKGRldmljZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJEZWZpbml0aW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQcm9jZXNzIHNoYWRlciB1c2luZyBzaGFkZXIgcHJvY2Vzc2luZyBvcHRpb25zLCB1dGlsaXppbmcgY2FjaGUgb2YgdGhlIFByb2dyYW1MaWJyYXJ5XG4gKlxuICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlciAtIFRoZSBzaGFkZXIgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci1wcm9jZXNzb3Itb3B0aW9ucy5qcycpLlNoYWRlclByb2Nlc3Nvck9wdGlvbnN9IHByb2Nlc3NpbmdPcHRpb25zIC1cbiAqIFRoZSBzaGFkZXIgcHJvY2Vzc2luZyBvcHRpb25zLlxuICogQHJldHVybnMge1NoYWRlcn0gVGhlIHByb2Nlc3NlZCBzaGFkZXIuXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NTaGFkZXIoc2hhZGVyLCBwcm9jZXNzaW5nT3B0aW9ucykge1xuXG4gICAgRGVidWcuYXNzZXJ0KHNoYWRlcik7XG4gICAgY29uc3Qgc2hhZGVyRGVmaW5pdGlvbiA9IHNoYWRlci5kZWZpbml0aW9uO1xuXG4gICAgLy8gJ3NoYWRlcicgZ2VuZXJhdG9yIGZvciBhIG1hdGVyaWFsIC0gc2ltcGx5IHJldHVybiBleGlzdGluZyBzaGFkZXIgZGVmaW5pdGlvbi4gVXNlIGdlbmVyYXRvciBhbmQgZ2V0UHJvZ3JhbVxuICAgIC8vIHRvIGFsbG93IGZvciBzaGFkZXIgcHJvY2Vzc2luZyB0byBiZSBjYWNoZWRcbiAgICBjb25zdCBuYW1lID0gc2hhZGVyRGVmaW5pdGlvbi5uYW1lID8/ICdzaGFkZXInO1xuXG4gICAgLy8gdW5pcXVlIG5hbWUgYmFzZWQgb2YgdGhlIHNoYWRlciBpZFxuICAgIGNvbnN0IGtleSA9IGAke25hbWV9LWlkLSR7c2hhZGVyLmlkfWA7XG5cbiAgICBjb25zdCBtYXRlcmlhbEdlbmVyYXRvciA9IG5ldyBTaGFkZXJHZW5lcmF0b3JQYXNzVGhyb3VnaChrZXksIHNoYWRlckRlZmluaXRpb24pO1xuXG4gICAgLy8gdGVtcG9yYXJpbHkgcmVnaXN0ZXIgdGhlIHByb2dyYW0gZ2VuZXJhdG9yXG4gICAgY29uc3QgbGlicmFyeU1vZHVsZU5hbWUgPSAnc2hhZGVyJztcbiAgICBjb25zdCBsaWJyYXJ5ID0gZ2V0UHJvZ3JhbUxpYnJhcnkoc2hhZGVyLmRldmljZSk7XG4gICAgRGVidWcuYXNzZXJ0KCFsaWJyYXJ5LmlzUmVnaXN0ZXJlZChsaWJyYXJ5TW9kdWxlTmFtZSkpO1xuICAgIGxpYnJhcnkucmVnaXN0ZXIobGlicmFyeU1vZHVsZU5hbWUsIG1hdGVyaWFsR2VuZXJhdG9yKTtcblxuICAgIC8vIGdlbmVyYXRlIHNoYWRlciB2YXJpYW50IC0gaXRzIHRoZSBzYW1lIHNoYWRlciwgYnV0IHdpdGggZGlmZmVyZW50IHByb2Nlc3Npbmcgb3B0aW9uc1xuICAgIGNvbnN0IHZhcmlhbnQgPSBsaWJyYXJ5LmdldFByb2dyYW0obGlicmFyeU1vZHVsZU5hbWUsIHt9LCBwcm9jZXNzaW5nT3B0aW9ucyk7XG5cbiAgICAvLyB1bnJlZ2lzdGVyIGl0IGFnYWluXG4gICAgbGlicmFyeS51bnJlZ2lzdGVyKGxpYnJhcnlNb2R1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYW50O1xufVxuXG5cbnNoYWRlckNodW5rcy5jcmVhdGVTaGFkZXIgPSBjcmVhdGVTaGFkZXI7XG5zaGFkZXJDaHVua3MuY3JlYXRlU2hhZGVyRnJvbUNvZGUgPSBjcmVhdGVTaGFkZXJGcm9tQ29kZTtcblxuZXhwb3J0IHsgY3JlYXRlU2hhZGVyLCBjcmVhdGVTaGFkZXJGcm9tQ29kZSwgcHJvY2Vzc1NoYWRlciB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZVNoYWRlciIsImRldmljZSIsInZzTmFtZSIsImZzTmFtZSIsInVzZVRyYW5zZm9ybUZlZWRiYWNrIiwic2hhZGVyRGVmaW5pdGlvbk9wdGlvbnMiLCJfZXh0ZW5kcyIsIlNoYWRlciIsIlNoYWRlclV0aWxzIiwiY3JlYXRlRGVmaW5pdGlvbiIsIm5hbWUiLCJ2ZXJ0ZXhDb2RlIiwic2hhZGVyQ2h1bmtzIiwiZnJhZ21lbnRDb2RlIiwiY3JlYXRlU2hhZGVyRnJvbUNvZGUiLCJ2c0NvZGUiLCJmc0NvZGUiLCJ1bmlxdWVOYW1lIiwiYXR0cmlidXRlcyIsIkRlYnVnIiwiYXNzZXJ0IiwicHJvZ3JhbUxpYnJhcnkiLCJnZXRQcm9ncmFtTGlicmFyeSIsInNoYWRlciIsImdldENhY2hlZFNoYWRlciIsInNldENhY2hlZFNoYWRlciIsIlNoYWRlckdlbmVyYXRvclBhc3NUaHJvdWdoIiwiU2hhZGVyR2VuZXJhdG9yIiwiY29uc3RydWN0b3IiLCJrZXkiLCJzaGFkZXJEZWZpbml0aW9uIiwiZ2VuZXJhdGVLZXkiLCJvcHRpb25zIiwiY3JlYXRlU2hhZGVyRGVmaW5pdGlvbiIsInByb2Nlc3NTaGFkZXIiLCJwcm9jZXNzaW5nT3B0aW9ucyIsIl9zaGFkZXJEZWZpbml0aW9uJG5hbSIsImRlZmluaXRpb24iLCJpZCIsIm1hdGVyaWFsR2VuZXJhdG9yIiwibGlicmFyeU1vZHVsZU5hbWUiLCJsaWJyYXJ5IiwiaXNSZWdpc3RlcmVkIiwicmVnaXN0ZXIiLCJ2YXJpYW50IiwiZ2V0UHJvZ3JhbSIsInVucmVnaXN0ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLFlBQVlBLENBQUNDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLG9CQUFvQixHQUFHLEtBQUssRUFBRUMsdUJBQXVCLEdBQUcsRUFBRSxFQUFFO0FBRXRHO0FBQ0EsRUFBQSxJQUFJLE9BQU9ELG9CQUFvQixLQUFLLFNBQVMsRUFBRTtJQUMzQ0MsdUJBQXVCLENBQUNELG9CQUFvQixHQUFHQSxvQkFBb0IsQ0FBQTtBQUN2RSxHQUFDLE1BQU0sSUFBSSxPQUFPQSxvQkFBb0IsS0FBSyxRQUFRLEVBQUU7QUFDakRDLElBQUFBLHVCQUF1QixHQUFBQyxRQUFBLENBQUEsRUFBQSxFQUNoQkQsdUJBQXVCLEVBQ3ZCRCxvQkFBb0IsQ0FDMUIsQ0FBQTtBQUNMLEdBQUE7QUFFQSxFQUFBLE9BQU8sSUFBSUcsTUFBTSxDQUFDTixNQUFNLEVBQUVPLFdBQVcsQ0FBQ0MsZ0JBQWdCLENBQUNSLE1BQU0sRUFBQUssUUFBQSxLQUN0REQsdUJBQXVCLEVBQUE7QUFDMUJLLElBQUFBLElBQUksRUFBRyxDQUFBLEVBQUVSLE1BQU8sQ0FBQSxDQUFBLEVBQUdDLE1BQU8sQ0FBQyxDQUFBO0FBQzNCUSxJQUFBQSxVQUFVLEVBQUVDLFlBQVksQ0FBQ1YsTUFBTSxDQUFDO0lBQ2hDVyxZQUFZLEVBQUVELFlBQVksQ0FBQ1QsTUFBTSxDQUFBO0FBQUMsR0FBQSxDQUNyQyxDQUFDLENBQUMsQ0FBQTtBQUNQLENBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTVyxvQkFBb0JBLENBQUNiLE1BQU0sRUFBRWMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxFQUFFZCxvQkFBb0IsR0FBRyxLQUFLLEVBQUVDLHVCQUF1QixHQUFHLEVBQUUsRUFBRTtBQUV0STtBQUNBYyxFQUFBQSxLQUFLLENBQUNDLE1BQU0sQ0FBQyxPQUFPRixVQUFVLEtBQUssU0FBUyxDQUFDLENBQUE7O0FBRTdDO0FBQ0EsRUFBQSxJQUFJLE9BQU9kLG9CQUFvQixLQUFLLFNBQVMsRUFBRTtJQUMzQ0MsdUJBQXVCLENBQUNELG9CQUFvQixHQUFHQSxvQkFBb0IsQ0FBQTtBQUN2RSxHQUFDLE1BQU0sSUFBSSxPQUFPQSxvQkFBb0IsS0FBSyxRQUFRLEVBQUU7QUFDakRDLElBQUFBLHVCQUF1QixHQUFBQyxRQUFBLENBQUEsRUFBQSxFQUNoQkQsdUJBQXVCLEVBQ3ZCRCxvQkFBb0IsQ0FDMUIsQ0FBQTtBQUNMLEdBQUE7QUFFQSxFQUFBLE1BQU1pQixjQUFjLEdBQUdDLGlCQUFpQixDQUFDckIsTUFBTSxDQUFDLENBQUE7QUFDaEQsRUFBQSxJQUFJc0IsTUFBTSxHQUFHRixjQUFjLENBQUNHLGVBQWUsQ0FBQ1AsVUFBVSxDQUFDLENBQUE7RUFDdkQsSUFBSSxDQUFDTSxNQUFNLEVBQUU7QUFDVEEsSUFBQUEsTUFBTSxHQUFHLElBQUloQixNQUFNLENBQUNOLE1BQU0sRUFBRU8sV0FBVyxDQUFDQyxnQkFBZ0IsQ0FBQ1IsTUFBTSxFQUFBSyxRQUFBLEtBQ3hERCx1QkFBdUIsRUFBQTtBQUMxQkssTUFBQUEsSUFBSSxFQUFFTyxVQUFVO0FBQ2hCTixNQUFBQSxVQUFVLEVBQUVJLE1BQU07QUFDbEJGLE1BQUFBLFlBQVksRUFBRUcsTUFBTTtBQUNwQkUsTUFBQUEsVUFBVSxFQUFFQSxVQUFBQTtBQUFVLEtBQUEsQ0FDekIsQ0FBQyxDQUFDLENBQUE7QUFDSEcsSUFBQUEsY0FBYyxDQUFDSSxlQUFlLENBQUNSLFVBQVUsRUFBRU0sTUFBTSxDQUFDLENBQUE7QUFDdEQsR0FBQTtBQUNBLEVBQUEsT0FBT0EsTUFBTSxDQUFBO0FBQ2pCLENBQUE7QUFFQSxNQUFNRywwQkFBMEIsU0FBU0MsZUFBZSxDQUFDO0FBQ3JEQyxFQUFBQSxXQUFXQSxDQUFDQyxHQUFHLEVBQUVDLGdCQUFnQixFQUFFO0FBQy9CLElBQUEsS0FBSyxFQUFFLENBQUE7SUFDUCxJQUFJLENBQUNELEdBQUcsR0FBR0EsR0FBRyxDQUFBO0lBQ2QsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0EsZ0JBQWdCLENBQUE7QUFDNUMsR0FBQTtFQUVBQyxXQUFXQSxDQUFDQyxPQUFPLEVBQUU7SUFDakIsT0FBTyxJQUFJLENBQUNILEdBQUcsQ0FBQTtBQUNuQixHQUFBO0FBRUFJLEVBQUFBLHNCQUFzQkEsQ0FBQ2hDLE1BQU0sRUFBRStCLE9BQU8sRUFBRTtJQUNwQyxPQUFPLElBQUksQ0FBQ0YsZ0JBQWdCLENBQUE7QUFDaEMsR0FBQTtBQUNKLENBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0ksYUFBYUEsQ0FBQ1gsTUFBTSxFQUFFWSxpQkFBaUIsRUFBRTtBQUFBLEVBQUEsSUFBQUMscUJBQUEsQ0FBQTtBQUU5Q2pCLEVBQUFBLEtBQUssQ0FBQ0MsTUFBTSxDQUFDRyxNQUFNLENBQUMsQ0FBQTtBQUNwQixFQUFBLE1BQU1PLGdCQUFnQixHQUFHUCxNQUFNLENBQUNjLFVBQVUsQ0FBQTs7QUFFMUM7QUFDQTtFQUNBLE1BQU0zQixJQUFJLEdBQUEwQixDQUFBQSxxQkFBQSxHQUFHTixnQkFBZ0IsQ0FBQ3BCLElBQUksS0FBQSxJQUFBLEdBQUEwQixxQkFBQSxHQUFJLFFBQVEsQ0FBQTs7QUFFOUM7RUFDQSxNQUFNUCxHQUFHLEdBQUksQ0FBRW5CLEVBQUFBLElBQUssT0FBTWEsTUFBTSxDQUFDZSxFQUFHLENBQUMsQ0FBQSxDQUFBO0VBRXJDLE1BQU1DLGlCQUFpQixHQUFHLElBQUliLDBCQUEwQixDQUFDRyxHQUFHLEVBQUVDLGdCQUFnQixDQUFDLENBQUE7O0FBRS9FO0VBQ0EsTUFBTVUsaUJBQWlCLEdBQUcsUUFBUSxDQUFBO0FBQ2xDLEVBQUEsTUFBTUMsT0FBTyxHQUFHbkIsaUJBQWlCLENBQUNDLE1BQU0sQ0FBQ3RCLE1BQU0sQ0FBQyxDQUFBO0VBQ2hEa0IsS0FBSyxDQUFDQyxNQUFNLENBQUMsQ0FBQ3FCLE9BQU8sQ0FBQ0MsWUFBWSxDQUFDRixpQkFBaUIsQ0FBQyxDQUFDLENBQUE7QUFDdERDLEVBQUFBLE9BQU8sQ0FBQ0UsUUFBUSxDQUFDSCxpQkFBaUIsRUFBRUQsaUJBQWlCLENBQUMsQ0FBQTs7QUFFdEQ7QUFDQSxFQUFBLE1BQU1LLE9BQU8sR0FBR0gsT0FBTyxDQUFDSSxVQUFVLENBQUNMLGlCQUFpQixFQUFFLEVBQUUsRUFBRUwsaUJBQWlCLENBQUMsQ0FBQTs7QUFFNUU7QUFDQU0sRUFBQUEsT0FBTyxDQUFDSyxVQUFVLENBQUNOLGlCQUFpQixDQUFDLENBQUE7QUFFckMsRUFBQSxPQUFPSSxPQUFPLENBQUE7QUFDbEIsQ0FBQTtBQUdBaEMsWUFBWSxDQUFDWixZQUFZLEdBQUdBLFlBQVksQ0FBQTtBQUN4Q1ksWUFBWSxDQUFDRSxvQkFBb0IsR0FBR0Esb0JBQW9COzs7OyJ9
