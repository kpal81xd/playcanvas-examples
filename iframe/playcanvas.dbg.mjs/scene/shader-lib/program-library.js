import { Debug } from '../../core/debug.js';
import { hashCode } from '../../core/hash.js';
import { version, revision } from '../../core/core.js';
import { Shader } from '../../platform/graphics/shader.js';
import { SHADER_FORWARD, SHADER_SHADOW, SHADER_DEPTH, SHADER_PICK } from '../constants.js';
import { ShaderPass } from '../shader-pass.js';
import { StandardMaterialOptions } from '../materials/standard-material-options.js';

/**
 * A class responsible for creation and caching of required shaders.
 * There is a two level cache. The first level generates the shader based on the provided options.
 * The second level processes this generated shader using processing options - in most cases
 * modifies it to support uniform buffers.
 *
 * @ignore
 */
class ProgramLibrary {
  constructor(device, standardMaterial) {
    /**
     * A cache of shaders processed using processing options.
     *
     * @type {Map<string, Shader>}
     */
    this.processedCache = new Map();
    /**
     * A cache of shader definitions before processing.
     *
     * @type {Map<number, object>}
     */
    this.definitionsCache = new Map();
    /**
     * Named shader generators.
     *
     * @type {Map<string, import('./programs/shader-generator.js').ShaderGenerator>}
     */
    this._generators = new Map();
    this._device = device;
    this._isClearingCache = false;
    this._precached = false;

    // Unique non-cached programs collection to dump and update game shaders cache
    this._programsCollection = [];
    this._defaultStdMatOption = new StandardMaterialOptions();
    this._defaultStdMatOptionMin = new StandardMaterialOptions();
    standardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, standardMaterial, null, [], SHADER_FORWARD, null);
    standardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, standardMaterial, null, SHADER_SHADOW, null);
    device.on('destroy:shader', shader => {
      this.removeFromCache(shader);
    });
  }
  destroy() {
    this.clearCache();
  }
  register(name, generator) {
    if (!this._generators.has(name)) {
      this._generators.set(name, generator);
    }
  }
  unregister(name) {
    if (this._generators.has(name)) {
      this._generators.delete(name);
    }
  }
  isRegistered(name) {
    return this._generators.has(name);
  }

  /**
   * Returns a generated shader definition for the specified options. They key is used to cache the
   * shader definition.
   * @param {import('./programs/shader-generator.js').ShaderGenerator} generator - The generator
   * to use.
   * @param {string} name - The unique name of the shader generator.
   * @param {number} key - A unique key representing the shader options.
   * @param {object} options - The shader options.
   * @returns {object} - The shader definition.
   */
  generateShaderDefinition(generator, name, key, options) {
    let def = this.definitionsCache.get(key);
    if (!def) {
      var _options$litOptions, _options$litOptions2, _def$name;
      let lights;
      if ((_options$litOptions = options.litOptions) != null && _options$litOptions.lights) {
        lights = options.litOptions.lights;
        options.litOptions.lights = lights.map(function (l) {
          // TODO: refactor this to avoid creating a clone of the light.
          const lcopy = l.clone ? l.clone() : l;
          lcopy.key = l.key;
          return lcopy;
        });
      }
      this.storeNewProgram(name, options);
      if ((_options$litOptions2 = options.litOptions) != null && _options$litOptions2.lights) options.litOptions.lights = lights;
      if (this._precached) Debug.log(`ProgramLibrary#getProgram: Cache miss for shader ${name} key ${key} after shaders precaching`);
      const device = this._device;
      def = generator.createShaderDefinition(device, options);
      def.name = (_def$name = def.name) != null ? _def$name : options.pass ? `${name}-pass:${options.pass}` : name;
      this.definitionsCache.set(key, def);
    }
    return def;
  }
  getCachedShader(key) {
    return this.processedCache.get(key);
  }
  setCachedShader(key, shader) {
    this.processedCache.set(key, shader);
  }
  getProgram(name, options, processingOptions, userMaterialId) {
    const generator = this._generators.get(name);
    if (!generator) {
      Debug.warn(`ProgramLibrary#getProgram: No program library functions registered for: ${name}`);
      return null;
    }

    // we have a key for shader source code generation, a key for its further processing to work with
    // uniform buffers, and a final key to get the processed shader from the cache
    const generationKeyString = generator.generateKey(options);
    const generationKey = hashCode(generationKeyString);
    const processingKeyString = processingOptions.generateKey(this._device);
    const processingKey = hashCode(processingKeyString);
    const totalKey = `${generationKey}#${processingKey}`;

    // do we have final processed shader
    let processedShader = this.getCachedShader(totalKey);
    if (!processedShader) {
      // get generated shader
      const generatedShaderDef = this.generateShaderDefinition(generator, name, generationKey, options);
      Debug.assert(generatedShaderDef);

      // use shader pass name if known
      let passName = '';
      let shaderPassInfo;
      if (options.pass !== undefined) {
        shaderPassInfo = ShaderPass.get(this._device).getByIndex(options.pass);
        passName = `-${shaderPassInfo.name}`;
      }

      // fire an event to allow the shader to be modified by the user. Note that any modifications are applied
      // to all materials using the same generated shader, as the cache key is not modified.
      this._device.fire('shader:generate', {
        userMaterialId,
        shaderPassInfo,
        definition: generatedShaderDef
      });

      // create a shader definition for the shader that will include the processingOptions
      const shaderDefinition = {
        name: `${generatedShaderDef.name}${passName}-proc`,
        attributes: generatedShaderDef.attributes,
        vshader: generatedShaderDef.vshader,
        fshader: generatedShaderDef.fshader,
        processingOptions: processingOptions
      };

      // add new shader to the processed cache
      processedShader = new Shader(this._device, shaderDefinition);

      // keep the keys in the debug mode
      Debug.call(() => {
        processedShader._generationKey = generationKeyString;
        processedShader._processingKey = processingKeyString;
      });
      this.setCachedShader(totalKey, processedShader);
    }
    return processedShader;
  }
  storeNewProgram(name, options) {
    let opt = {};
    if (name === "standard") {
      // For standard material saving all default values is overkill, so we store only diff
      const defaultMat = this._getDefaultStdMatOptions(options.pass);
      for (const p in options) {
        if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === "pass") opt[p] = options[p];
      }

      // Note: this was added in #4792 and it does not filter out the default values, like the loop above
      for (const p in options.litOptions) {
        opt[p] = options.litOptions[p];
      }
    } else {
      // Other shaders have only dozen params
      opt = options;
    }
    this._programsCollection.push(JSON.stringify({
      name: name,
      options: opt
    }));
  }

  // run pc.app.graphicsDevice.getProgramLibrary().dumpPrograms(); from browser console to build shader options script
  dumpPrograms() {
    let text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
    text += 'let shaders = [';
    if (this._programsCollection[0]) text += '\n\t' + this._programsCollection[0];
    for (let i = 1; i < this._programsCollection.length; ++i) {
      text += ',\n\t' + this._programsCollection[i];
    }
    text += '\n];\n';
    text += 'device.getProgramLibrary().precompile(shaders);\n';
    text += 'if (pc.version != \"' + version + '\" || pc.revision != \"' + revision + '\")\n';
    text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
    const element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', 'precompile-shaders.js');
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  clearCache() {
    this._isClearingCache = true;
    this.processedCache.forEach(shader => {
      shader.destroy();
    });
    this.processedCache.clear();
    this._isClearingCache = false;
  }

  /**
   * Remove shader from the cache. This function does not destroy it, that is the responsibility
   * of the caller.
   *
   * @param {Shader} shader - The shader to be removed.
   */
  removeFromCache(shader) {
    // don't delete by one when clearing whole cache
    if (this._isClearingCache) return;
    this.processedCache.forEach((cachedShader, key) => {
      if (shader === cachedShader) {
        this.processedCache.delete(key);
      }
    });
  }
  _getDefaultStdMatOptions(pass) {
    const shaderPassInfo = ShaderPass.get(this._device).getByIndex(pass);
    return pass === SHADER_DEPTH || pass === SHADER_PICK || shaderPassInfo.isShadow ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
  }
  precompile(cache) {
    if (cache) {
      const shaders = new Array(cache.length);
      for (let i = 0; i < cache.length; i++) {
        // default options for the standard materials are not stored, and so they are inserted
        // back into the loaded options
        if (cache[i].name === "standard") {
          const opt = cache[i].options;
          const defaultMat = this._getDefaultStdMatOptions(opt.pass);
          for (const p in defaultMat) {
            if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];
          }
        }
        shaders[i] = this.getProgram(cache[i].name, cache[i].options);
      }
    }
    this._precached = true;
  }
}

export { ProgramLibrary };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3JhbS1saWJyYXJ5LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvc2NlbmUvc2hhZGVyLWxpYi9wcm9ncmFtLWxpYnJhcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IGhhc2hDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9oYXNoLmpzJztcbmltcG9ydCB7IHZlcnNpb24sIHJldmlzaW9uIH0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLmpzJztcblxuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3Mvc2hhZGVyLmpzJztcblxuaW1wb3J0IHsgU0hBREVSX0ZPUldBUkQsIFNIQURFUl9ERVBUSCwgU0hBREVSX1BJQ0ssIFNIQURFUl9TSEFET1cgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgU2hhZGVyUGFzcyB9IGZyb20gJy4uL3NoYWRlci1wYXNzLmpzJztcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWxPcHRpb25zIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL3N0YW5kYXJkLW1hdGVyaWFsLW9wdGlvbnMuanMnO1xuXG4vKipcbiAqIEEgY2xhc3MgcmVzcG9uc2libGUgZm9yIGNyZWF0aW9uIGFuZCBjYWNoaW5nIG9mIHJlcXVpcmVkIHNoYWRlcnMuXG4gKiBUaGVyZSBpcyBhIHR3byBsZXZlbCBjYWNoZS4gVGhlIGZpcnN0IGxldmVsIGdlbmVyYXRlcyB0aGUgc2hhZGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICogVGhlIHNlY29uZCBsZXZlbCBwcm9jZXNzZXMgdGhpcyBnZW5lcmF0ZWQgc2hhZGVyIHVzaW5nIHByb2Nlc3Npbmcgb3B0aW9ucyAtIGluIG1vc3QgY2FzZXNcbiAqIG1vZGlmaWVzIGl0IHRvIHN1cHBvcnQgdW5pZm9ybSBidWZmZXJzLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgUHJvZ3JhbUxpYnJhcnkge1xuICAgIC8qKlxuICAgICAqIEEgY2FjaGUgb2Ygc2hhZGVycyBwcm9jZXNzZWQgdXNpbmcgcHJvY2Vzc2luZyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIFNoYWRlcj59XG4gICAgICovXG4gICAgcHJvY2Vzc2VkQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIG9mIHNoYWRlciBkZWZpbml0aW9ucyBiZWZvcmUgcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBvYmplY3Q+fVxuICAgICAqL1xuICAgIGRlZmluaXRpb25zQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbiAgICAvKipcbiAgICAgKiBOYW1lZCBzaGFkZXIgZ2VuZXJhdG9ycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBpbXBvcnQoJy4vcHJvZ3JhbXMvc2hhZGVyLWdlbmVyYXRvci5qcycpLlNoYWRlckdlbmVyYXRvcj59XG4gICAgICovXG4gICAgX2dlbmVyYXRvcnMgPSBuZXcgTWFwKCk7XG5cbiAgICBjb25zdHJ1Y3RvcihkZXZpY2UsIHN0YW5kYXJkTWF0ZXJpYWwpIHtcbiAgICAgICAgdGhpcy5fZGV2aWNlID0gZGV2aWNlO1xuICAgICAgICB0aGlzLl9pc0NsZWFyaW5nQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJlY2FjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gVW5pcXVlIG5vbi1jYWNoZWQgcHJvZ3JhbXMgY29sbGVjdGlvbiB0byBkdW1wIGFuZCB1cGRhdGUgZ2FtZSBzaGFkZXJzIGNhY2hlXG4gICAgICAgIHRoaXMuX3Byb2dyYW1zQ29sbGVjdGlvbiA9IFtdO1xuICAgICAgICB0aGlzLl9kZWZhdWx0U3RkTWF0T3B0aW9uID0gbmV3IFN0YW5kYXJkTWF0ZXJpYWxPcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRTdGRNYXRPcHRpb25NaW4gPSBuZXcgU3RhbmRhcmRNYXRlcmlhbE9wdGlvbnMoKTtcblxuICAgICAgICBzdGFuZGFyZE1hdGVyaWFsLnNoYWRlck9wdEJ1aWxkZXIudXBkYXRlUmVmKFxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFN0ZE1hdE9wdGlvbiwge30sIHN0YW5kYXJkTWF0ZXJpYWwsIG51bGwsIFtdLCBTSEFERVJfRk9SV0FSRCwgbnVsbCk7XG4gICAgICAgIHN0YW5kYXJkTWF0ZXJpYWwuc2hhZGVyT3B0QnVpbGRlci51cGRhdGVNaW5SZWYoXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0U3RkTWF0T3B0aW9uTWluLCB7fSwgc3RhbmRhcmRNYXRlcmlhbCwgbnVsbCwgU0hBREVSX1NIQURPVywgbnVsbCk7XG5cbiAgICAgICAgZGV2aWNlLm9uKCdkZXN0cm95OnNoYWRlcicsIChzaGFkZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbUNhY2hlKHNoYWRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyKG5hbWUsIGdlbmVyYXRvcikge1xuICAgICAgICBpZiAoIXRoaXMuX2dlbmVyYXRvcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0b3JzLnNldChuYW1lLCBnZW5lcmF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5yZWdpc3RlcihuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZW5lcmF0b3JzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdG9ycy5kZWxldGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlZ2lzdGVyZWQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdG9ycy5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGdlbmVyYXRlZCBzaGFkZXIgZGVmaW5pdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBvcHRpb25zLiBUaGV5IGtleSBpcyB1c2VkIHRvIGNhY2hlIHRoZVxuICAgICAqIHNoYWRlciBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuL3Byb2dyYW1zL3NoYWRlci1nZW5lcmF0b3IuanMnKS5TaGFkZXJHZW5lcmF0b3J9IGdlbmVyYXRvciAtIFRoZSBnZW5lcmF0b3JcbiAgICAgKiB0byB1c2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgdW5pcXVlIG5hbWUgb2YgdGhlIHNoYWRlciBnZW5lcmF0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGtleSAtIEEgdW5pcXVlIGtleSByZXByZXNlbnRpbmcgdGhlIHNoYWRlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIHNoYWRlciBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gVGhlIHNoYWRlciBkZWZpbml0aW9uLlxuICAgICAqL1xuICAgIGdlbmVyYXRlU2hhZGVyRGVmaW5pdGlvbihnZW5lcmF0b3IsIG5hbWUsIGtleSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZGVmID0gdGhpcy5kZWZpbml0aW9uc0NhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgICAgbGV0IGxpZ2h0cztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxpdE9wdGlvbnM/LmxpZ2h0cykge1xuICAgICAgICAgICAgICAgIGxpZ2h0cyA9IG9wdGlvbnMubGl0T3B0aW9ucy5saWdodHM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5saXRPcHRpb25zLmxpZ2h0cyA9IGxpZ2h0cy5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyB0byBhdm9pZCBjcmVhdGluZyBhIGNsb25lIG9mIHRoZSBsaWdodC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGNvcHkgPSBsLmNsb25lID8gbC5jbG9uZSgpIDogbDtcbiAgICAgICAgICAgICAgICAgICAgbGNvcHkua2V5ID0gbC5rZXk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsY29weTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdG9yZU5ld1Byb2dyYW0obmFtZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxpdE9wdGlvbnM/LmxpZ2h0cylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxpdE9wdGlvbnMubGlnaHRzID0gbGlnaHRzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJlY2FjaGVkKVxuICAgICAgICAgICAgICAgIERlYnVnLmxvZyhgUHJvZ3JhbUxpYnJhcnkjZ2V0UHJvZ3JhbTogQ2FjaGUgbWlzcyBmb3Igc2hhZGVyICR7bmFtZX0ga2V5ICR7a2V5fSBhZnRlciBzaGFkZXJzIHByZWNhY2hpbmdgKTtcblxuICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5fZGV2aWNlO1xuICAgICAgICAgICAgZGVmID0gZ2VuZXJhdG9yLmNyZWF0ZVNoYWRlckRlZmluaXRpb24oZGV2aWNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlZi5uYW1lID0gZGVmLm5hbWUgPz8gKG9wdGlvbnMucGFzcyA/IGAke25hbWV9LXBhc3M6JHtvcHRpb25zLnBhc3N9YCA6IG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uc0NhY2hlLnNldChrZXksIGRlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG5cbiAgICBnZXRDYWNoZWRTaGFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NlZENhY2hlLmdldChrZXkpO1xuICAgIH1cblxuICAgIHNldENhY2hlZFNoYWRlcihrZXksIHNoYWRlcikge1xuICAgICAgICB0aGlzLnByb2Nlc3NlZENhY2hlLnNldChrZXksIHNoYWRlcik7XG4gICAgfVxuXG4gICAgZ2V0UHJvZ3JhbShuYW1lLCBvcHRpb25zLCBwcm9jZXNzaW5nT3B0aW9ucywgdXNlck1hdGVyaWFsSWQpIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gdGhpcy5fZ2VuZXJhdG9ycy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBEZWJ1Zy53YXJuKGBQcm9ncmFtTGlicmFyeSNnZXRQcm9ncmFtOiBObyBwcm9ncmFtIGxpYnJhcnkgZnVuY3Rpb25zIHJlZ2lzdGVyZWQgZm9yOiAke25hbWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGhhdmUgYSBrZXkgZm9yIHNoYWRlciBzb3VyY2UgY29kZSBnZW5lcmF0aW9uLCBhIGtleSBmb3IgaXRzIGZ1cnRoZXIgcHJvY2Vzc2luZyB0byB3b3JrIHdpdGhcbiAgICAgICAgLy8gdW5pZm9ybSBidWZmZXJzLCBhbmQgYSBmaW5hbCBrZXkgdG8gZ2V0IHRoZSBwcm9jZXNzZWQgc2hhZGVyIGZyb20gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25LZXlTdHJpbmcgPSBnZW5lcmF0b3IuZ2VuZXJhdGVLZXkob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25LZXkgPSBoYXNoQ29kZShnZW5lcmF0aW9uS2V5U3RyaW5nKTtcblxuICAgICAgICBjb25zdCBwcm9jZXNzaW5nS2V5U3RyaW5nID0gcHJvY2Vzc2luZ09wdGlvbnMuZ2VuZXJhdGVLZXkodGhpcy5fZGV2aWNlKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2luZ0tleSA9IGhhc2hDb2RlKHByb2Nlc3NpbmdLZXlTdHJpbmcpO1xuXG4gICAgICAgIGNvbnN0IHRvdGFsS2V5ID0gYCR7Z2VuZXJhdGlvbktleX0jJHtwcm9jZXNzaW5nS2V5fWA7XG5cbiAgICAgICAgLy8gZG8gd2UgaGF2ZSBmaW5hbCBwcm9jZXNzZWQgc2hhZGVyXG4gICAgICAgIGxldCBwcm9jZXNzZWRTaGFkZXIgPSB0aGlzLmdldENhY2hlZFNoYWRlcih0b3RhbEtleSk7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkU2hhZGVyKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBnZW5lcmF0ZWQgc2hhZGVyXG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRTaGFkZXJEZWYgPSB0aGlzLmdlbmVyYXRlU2hhZGVyRGVmaW5pdGlvbihnZW5lcmF0b3IsIG5hbWUsIGdlbmVyYXRpb25LZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgRGVidWcuYXNzZXJ0KGdlbmVyYXRlZFNoYWRlckRlZik7XG5cbiAgICAgICAgICAgIC8vIHVzZSBzaGFkZXIgcGFzcyBuYW1lIGlmIGtub3duXG4gICAgICAgICAgICBsZXQgcGFzc05hbWUgPSAnJztcbiAgICAgICAgICAgIGxldCBzaGFkZXJQYXNzSW5mbztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNoYWRlclBhc3NJbmZvID0gU2hhZGVyUGFzcy5nZXQodGhpcy5fZGV2aWNlKS5nZXRCeUluZGV4KG9wdGlvbnMucGFzcyk7XG4gICAgICAgICAgICAgICAgcGFzc05hbWUgPSBgLSR7c2hhZGVyUGFzc0luZm8ubmFtZX1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaXJlIGFuIGV2ZW50IHRvIGFsbG93IHRoZSBzaGFkZXIgdG8gYmUgbW9kaWZpZWQgYnkgdGhlIHVzZXIuIE5vdGUgdGhhdCBhbnkgbW9kaWZpY2F0aW9ucyBhcmUgYXBwbGllZFxuICAgICAgICAgICAgLy8gdG8gYWxsIG1hdGVyaWFscyB1c2luZyB0aGUgc2FtZSBnZW5lcmF0ZWQgc2hhZGVyLCBhcyB0aGUgY2FjaGUga2V5IGlzIG5vdCBtb2RpZmllZC5cbiAgICAgICAgICAgIHRoaXMuX2RldmljZS5maXJlKCdzaGFkZXI6Z2VuZXJhdGUnLCB7XG4gICAgICAgICAgICAgICAgdXNlck1hdGVyaWFsSWQsXG4gICAgICAgICAgICAgICAgc2hhZGVyUGFzc0luZm8sXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogZ2VuZXJhdGVkU2hhZGVyRGVmXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgc2hhZGVyIGRlZmluaXRpb24gZm9yIHRoZSBzaGFkZXIgdGhhdCB3aWxsIGluY2x1ZGUgdGhlIHByb2Nlc3NpbmdPcHRpb25zXG4gICAgICAgICAgICBjb25zdCBzaGFkZXJEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGAke2dlbmVyYXRlZFNoYWRlckRlZi5uYW1lfSR7cGFzc05hbWV9LXByb2NgLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGdlbmVyYXRlZFNoYWRlckRlZi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIHZzaGFkZXI6IGdlbmVyYXRlZFNoYWRlckRlZi52c2hhZGVyLFxuICAgICAgICAgICAgICAgIGZzaGFkZXI6IGdlbmVyYXRlZFNoYWRlckRlZi5mc2hhZGVyLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdPcHRpb25zOiBwcm9jZXNzaW5nT3B0aW9uc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gYWRkIG5ldyBzaGFkZXIgdG8gdGhlIHByb2Nlc3NlZCBjYWNoZVxuICAgICAgICAgICAgcHJvY2Vzc2VkU2hhZGVyID0gbmV3IFNoYWRlcih0aGlzLl9kZXZpY2UsIHNoYWRlckRlZmluaXRpb24pO1xuXG4gICAgICAgICAgICAvLyBrZWVwIHRoZSBrZXlzIGluIHRoZSBkZWJ1ZyBtb2RlXG4gICAgICAgICAgICBEZWJ1Zy5jYWxsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRTaGFkZXIuX2dlbmVyYXRpb25LZXkgPSBnZW5lcmF0aW9uS2V5U3RyaW5nO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZFNoYWRlci5fcHJvY2Vzc2luZ0tleSA9IHByb2Nlc3NpbmdLZXlTdHJpbmc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zZXRDYWNoZWRTaGFkZXIodG90YWxLZXksIHByb2Nlc3NlZFNoYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkU2hhZGVyO1xuICAgIH1cblxuICAgIHN0b3JlTmV3UHJvZ3JhbShuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBvcHQgPSB7fTtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwic3RhbmRhcmRcIikge1xuICAgICAgICAgICAgLy8gRm9yIHN0YW5kYXJkIG1hdGVyaWFsIHNhdmluZyBhbGwgZGVmYXVsdCB2YWx1ZXMgaXMgb3ZlcmtpbGwsIHNvIHdlIHN0b3JlIG9ubHkgZGlmZlxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdE1hdCA9IHRoaXMuX2dldERlZmF1bHRTdGRNYXRPcHRpb25zKG9wdGlvbnMucGFzcyk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKChvcHRpb25zLmhhc093blByb3BlcnR5KHApICYmIGRlZmF1bHRNYXRbcF0gIT09IG9wdGlvbnNbcF0pIHx8IHAgPT09IFwicGFzc1wiKVxuICAgICAgICAgICAgICAgICAgICBvcHRbcF0gPSBvcHRpb25zW3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGlzIHdhcyBhZGRlZCBpbiAjNDc5MiBhbmQgaXQgZG9lcyBub3QgZmlsdGVyIG91dCB0aGUgZGVmYXVsdCB2YWx1ZXMsIGxpa2UgdGhlIGxvb3AgYWJvdmVcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBvcHRpb25zLmxpdE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRbcF0gPSBvcHRpb25zLmxpdE9wdGlvbnNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlciBzaGFkZXJzIGhhdmUgb25seSBkb3plbiBwYXJhbXNcbiAgICAgICAgICAgIG9wdCA9IG9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm9ncmFtc0NvbGxlY3Rpb24ucHVzaChKU09OLnN0cmluZ2lmeSh7IG5hbWU6IG5hbWUsIG9wdGlvbnM6IG9wdCB9KSk7XG4gICAgfVxuXG4gICAgLy8gcnVuIHBjLmFwcC5ncmFwaGljc0RldmljZS5nZXRQcm9ncmFtTGlicmFyeSgpLmR1bXBQcm9ncmFtcygpOyBmcm9tIGJyb3dzZXIgY29uc29sZSB0byBidWlsZCBzaGFkZXIgb3B0aW9ucyBzY3JpcHRcbiAgICBkdW1wUHJvZ3JhbXMoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gJ2xldCBkZXZpY2UgPSBwYy5hcHAgPyBwYy5hcHAuZ3JhcGhpY3NEZXZpY2UgOiBwYy5BcHBsaWNhdGlvbi5nZXRBcHBsaWNhdGlvbigpLmdyYXBoaWNzRGV2aWNlO1xcbic7XG4gICAgICAgIHRleHQgKz0gJ2xldCBzaGFkZXJzID0gWyc7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtc0NvbGxlY3Rpb25bMF0pXG4gICAgICAgICAgICB0ZXh0ICs9ICdcXG5cXHQnICsgdGhpcy5fcHJvZ3JhbXNDb2xsZWN0aW9uWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX3Byb2dyYW1zQ29sbGVjdGlvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGV4dCArPSAnLFxcblxcdCcgKyB0aGlzLl9wcm9ncmFtc0NvbGxlY3Rpb25baV07XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCArPSAnXFxuXTtcXG4nO1xuICAgICAgICB0ZXh0ICs9ICdkZXZpY2UuZ2V0UHJvZ3JhbUxpYnJhcnkoKS5wcmVjb21waWxlKHNoYWRlcnMpO1xcbic7XG4gICAgICAgIHRleHQgKz0gJ2lmIChwYy52ZXJzaW9uICE9IFxcXCInICsgdmVyc2lvbiArICdcXFwiIHx8IHBjLnJldmlzaW9uICE9IFxcXCInICsgcmV2aXNpb24gKyAnXFxcIilcXG4nO1xuICAgICAgICB0ZXh0ICs9ICdcXHRjb25zb2xlLndhcm4oXFxcInByZWNvbXBpbGUtc2hhZGVycy5qczogZW5naW5lIHZlcnNpb24gbWlzbWF0Y2gsIHJlYnVpbGQgc2hhZGVycyBsaWIgd2l0aCBjdXJyZW50IGVuZ2luZVxcXCIpOyc7XG5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudCh0ZXh0KSk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsICdwcmVjb21waWxlLXNoYWRlcnMuanMnKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LmNsaWNrKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5faXNDbGVhcmluZ0NhY2hlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnByb2Nlc3NlZENhY2hlLmZvckVhY2goKHNoYWRlcikgPT4ge1xuICAgICAgICAgICAgc2hhZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkQ2FjaGUuY2xlYXIoKTtcblxuICAgICAgICB0aGlzLl9pc0NsZWFyaW5nQ2FjaGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc2hhZGVyIGZyb20gdGhlIGNhY2hlLiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGRlc3Ryb3kgaXQsIHRoYXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5XG4gICAgICogb2YgdGhlIGNhbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2hhZGVyfSBzaGFkZXIgLSBUaGUgc2hhZGVyIHRvIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUNhY2hlKHNoYWRlcikge1xuICAgICAgICAvLyBkb24ndCBkZWxldGUgYnkgb25lIHdoZW4gY2xlYXJpbmcgd2hvbGUgY2FjaGVcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2xlYXJpbmdDYWNoZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLnByb2Nlc3NlZENhY2hlLmZvckVhY2goKGNhY2hlZFNoYWRlciwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hhZGVyID09PSBjYWNoZWRTaGFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZENhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfZ2V0RGVmYXVsdFN0ZE1hdE9wdGlvbnMocGFzcykge1xuICAgICAgICBjb25zdCBzaGFkZXJQYXNzSW5mbyA9IFNoYWRlclBhc3MuZ2V0KHRoaXMuX2RldmljZSkuZ2V0QnlJbmRleChwYXNzKTtcbiAgICAgICAgcmV0dXJuIChwYXNzID09PSBTSEFERVJfREVQVEggfHwgcGFzcyA9PT0gU0hBREVSX1BJQ0sgfHwgc2hhZGVyUGFzc0luZm8uaXNTaGFkb3cpID9cbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRTdGRNYXRPcHRpb25NaW4gOiB0aGlzLl9kZWZhdWx0U3RkTWF0T3B0aW9uO1xuICAgIH1cblxuICAgIHByZWNvbXBpbGUoY2FjaGUpIHtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXJzID0gbmV3IEFycmF5KGNhY2hlLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBzdGFuZGFyZCBtYXRlcmlhbHMgYXJlIG5vdCBzdG9yZWQsIGFuZCBzbyB0aGV5IGFyZSBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIC8vIGJhY2sgaW50byB0aGUgbG9hZGVkIG9wdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVbaV0ubmFtZSA9PT0gXCJzdGFuZGFyZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdCA9IGNhY2hlW2ldLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRNYXQgPSB0aGlzLl9nZXREZWZhdWx0U3RkTWF0T3B0aW9ucyhvcHQucGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBkZWZhdWx0TWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdE1hdC5oYXNPd25Qcm9wZXJ0eShwKSAmJiBvcHRbcF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRbcF0gPSBkZWZhdWx0TWF0W3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2hhZGVyc1tpXSA9IHRoaXMuZ2V0UHJvZ3JhbShjYWNoZVtpXS5uYW1lLCBjYWNoZVtpXS5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmVjYWNoZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUHJvZ3JhbUxpYnJhcnkgfTtcbiJdLCJuYW1lcyI6WyJQcm9ncmFtTGlicmFyeSIsImNvbnN0cnVjdG9yIiwiZGV2aWNlIiwic3RhbmRhcmRNYXRlcmlhbCIsInByb2Nlc3NlZENhY2hlIiwiTWFwIiwiZGVmaW5pdGlvbnNDYWNoZSIsIl9nZW5lcmF0b3JzIiwiX2RldmljZSIsIl9pc0NsZWFyaW5nQ2FjaGUiLCJfcHJlY2FjaGVkIiwiX3Byb2dyYW1zQ29sbGVjdGlvbiIsIl9kZWZhdWx0U3RkTWF0T3B0aW9uIiwiU3RhbmRhcmRNYXRlcmlhbE9wdGlvbnMiLCJfZGVmYXVsdFN0ZE1hdE9wdGlvbk1pbiIsInNoYWRlck9wdEJ1aWxkZXIiLCJ1cGRhdGVSZWYiLCJTSEFERVJfRk9SV0FSRCIsInVwZGF0ZU1pblJlZiIsIlNIQURFUl9TSEFET1ciLCJvbiIsInNoYWRlciIsInJlbW92ZUZyb21DYWNoZSIsImRlc3Ryb3kiLCJjbGVhckNhY2hlIiwicmVnaXN0ZXIiLCJuYW1lIiwiZ2VuZXJhdG9yIiwiaGFzIiwic2V0IiwidW5yZWdpc3RlciIsImRlbGV0ZSIsImlzUmVnaXN0ZXJlZCIsImdlbmVyYXRlU2hhZGVyRGVmaW5pdGlvbiIsImtleSIsIm9wdGlvbnMiLCJkZWYiLCJnZXQiLCJfb3B0aW9ucyRsaXRPcHRpb25zIiwiX29wdGlvbnMkbGl0T3B0aW9uczIiLCJfZGVmJG5hbWUiLCJsaWdodHMiLCJsaXRPcHRpb25zIiwibWFwIiwibCIsImxjb3B5IiwiY2xvbmUiLCJzdG9yZU5ld1Byb2dyYW0iLCJEZWJ1ZyIsImxvZyIsImNyZWF0ZVNoYWRlckRlZmluaXRpb24iLCJwYXNzIiwiZ2V0Q2FjaGVkU2hhZGVyIiwic2V0Q2FjaGVkU2hhZGVyIiwiZ2V0UHJvZ3JhbSIsInByb2Nlc3NpbmdPcHRpb25zIiwidXNlck1hdGVyaWFsSWQiLCJ3YXJuIiwiZ2VuZXJhdGlvbktleVN0cmluZyIsImdlbmVyYXRlS2V5IiwiZ2VuZXJhdGlvbktleSIsImhhc2hDb2RlIiwicHJvY2Vzc2luZ0tleVN0cmluZyIsInByb2Nlc3NpbmdLZXkiLCJ0b3RhbEtleSIsInByb2Nlc3NlZFNoYWRlciIsImdlbmVyYXRlZFNoYWRlckRlZiIsImFzc2VydCIsInBhc3NOYW1lIiwic2hhZGVyUGFzc0luZm8iLCJ1bmRlZmluZWQiLCJTaGFkZXJQYXNzIiwiZ2V0QnlJbmRleCIsImZpcmUiLCJkZWZpbml0aW9uIiwic2hhZGVyRGVmaW5pdGlvbiIsImF0dHJpYnV0ZXMiLCJ2c2hhZGVyIiwiZnNoYWRlciIsIlNoYWRlciIsImNhbGwiLCJfZ2VuZXJhdGlvbktleSIsIl9wcm9jZXNzaW5nS2V5Iiwib3B0IiwiZGVmYXVsdE1hdCIsIl9nZXREZWZhdWx0U3RkTWF0T3B0aW9ucyIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsInB1c2giLCJKU09OIiwic3RyaW5naWZ5IiwiZHVtcFByb2dyYW1zIiwidGV4dCIsImkiLCJsZW5ndGgiLCJ2ZXJzaW9uIiwicmV2aXNpb24iLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsImZvckVhY2giLCJjbGVhciIsImNhY2hlZFNoYWRlciIsIlNIQURFUl9ERVBUSCIsIlNIQURFUl9QSUNLIiwiaXNTaGFkb3ciLCJwcmVjb21waWxlIiwiY2FjaGUiLCJzaGFkZXJzIiwiQXJyYXkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLGNBQWMsQ0FBQztBQXNCakJDLEVBQUFBLFdBQVdBLENBQUNDLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUU7QUFyQnRDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFKSSxJQUFBLElBQUEsQ0FLQUMsY0FBYyxHQUFHLElBQUlDLEdBQUcsRUFBRSxDQUFBO0FBRTFCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFKSSxJQUFBLElBQUEsQ0FLQUMsZ0JBQWdCLEdBQUcsSUFBSUQsR0FBRyxFQUFFLENBQUE7QUFFNUI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUpJLElBQUEsSUFBQSxDQUtBRSxXQUFXLEdBQUcsSUFBSUYsR0FBRyxFQUFFLENBQUE7SUFHbkIsSUFB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
