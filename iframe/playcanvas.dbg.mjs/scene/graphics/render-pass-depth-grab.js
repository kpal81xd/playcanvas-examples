import { FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DEPTH, PIXELFORMAT_R32F } from '../../platform/graphics/constants.js';
import { DebugGraphics } from '../../platform/graphics/debug-graphics.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { Texture } from '../../platform/graphics/texture.js';

// uniform names (first is current name, second one is deprecated name for compatibility)
const _depthUniformNames = ['uSceneDepthMap', 'uDepthMap'];

/**
 * A render pass implementing grab of a depth buffer, used on WebGL 2 and WebGPU devices.
 *
 * @ignore
 */
class RenderPassDepthGrab extends RenderPass {
  constructor(device, camera) {
    super(device);
    this.depthRenderTarget = null;
    this.camera = null;
    this.camera = camera;
  }
  destroy() {
    super.destroy();
    this.releaseRenderTarget(this.depthRenderTarget);
  }
  shouldReallocate(targetRT, sourceTexture) {
    // need to reallocate if dimensions don't match
    const width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
    const height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
    return !targetRT || width !== targetRT.width || height !== targetRT.height;
  }
  allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth) {
    // allocate texture buffer
    const texture = new Texture(device, {
      name: _depthUniformNames[0],
      format,
      width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
      height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    if (renderTarget) {
      // if reallocating RT size, release previous framebuffer
      renderTarget.destroyFrameBuffers();

      // assign new texture
      if (isDepth) {
        renderTarget._depthBuffer = texture;
      } else {
        renderTarget._colorBuffer = texture;
        renderTarget._colorBuffers = [texture];
      }
    } else {
      // create new render target with the texture
      renderTarget = new RenderTarget({
        name: 'DepthGrabRT',
        colorBuffer: isDepth ? null : texture,
        depthBuffer: isDepth ? texture : null,
        depth: !isDepth,
        stencil: device.supportsStencil,
        autoResolve: false
      });
    }
    return renderTarget;
  }
  releaseRenderTarget(rt) {
    if (rt) {
      rt.destroyTextureBuffers();
      rt.destroy();
    }
  }
  before() {
    var _camera$renderTarget, _camera$renderTarget$, _camera$renderTarget2, _camera$renderTarget3;
    const camera = this.camera;
    const device = this.device;
    const destinationRt = (_camera$renderTarget = camera == null ? void 0 : camera.renderTarget) != null ? _camera$renderTarget : device.backBuffer;
    let useDepthBuffer = true;
    let format = destinationRt.stencil ? PIXELFORMAT_DEPTHSTENCIL : PIXELFORMAT_DEPTH;
    if (device.isWebGPU) {
      const numSamples = destinationRt.samples;

      // when depth buffer is multi-sampled, instead of copying it out, we use custom shader to resolve it
      // to a R32F texture, used as a color attachment of the render target
      if (numSamples > 1) {
        format = PIXELFORMAT_R32F;
        useDepthBuffer = false;
      }
    }
    const sourceTexture = (_camera$renderTarget$ = (_camera$renderTarget2 = camera.renderTarget) == null ? void 0 : _camera$renderTarget2.depthBuffer) != null ? _camera$renderTarget$ : (_camera$renderTarget3 = camera.renderTarget) == null ? void 0 : _camera$renderTarget3.colorBuffer;

    // allocate / resize existing RT as needed
    if (this.shouldReallocate(this.depthRenderTarget, sourceTexture)) {
      this.releaseRenderTarget(this.depthRenderTarget);
      this.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, format, useDepthBuffer);
    }

    // assign uniform
    const colorBuffer = useDepthBuffer ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;
    _depthUniformNames.forEach(name => device.scope.resolve(name).setValue(colorBuffer));
  }
  execute() {
    const device = this.device;
    DebugGraphics.pushGpuMarker(device, 'GRAB-DEPTH');

    // WebGL2 multisampling depth handling: we resolve multi-sampled depth buffer to a single-sampled destination buffer.
    // We could use existing API and resolve depth first and then blit it to destination, but this avoids the extra copy.
    if (device.isWebGL2 && device.renderTarget.samples > 1) {
      // multi-sampled buffer
      const src = device.renderTarget.impl._glFrameBuffer;

      // single sampled destination buffer
      const dest = this.depthRenderTarget;
      device.renderTarget = dest;
      device.updateBegin();
      this.depthRenderTarget.impl.internalResolve(device, src, dest.impl._glFrameBuffer, this.depthRenderTarget, device.gl.DEPTH_BUFFER_BIT);
    } else {
      // copy depth
      device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);
    }
    DebugGraphics.popGpuMarker(device);
  }
}

export { RenderPassDepthGrab };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyLXBhc3MtZGVwdGgtZ3JhYi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL3NjZW5lL2dyYXBoaWNzL3JlbmRlci1wYXNzLWRlcHRoLWdyYWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQUREUkVTU19DTEFNUF9UT19FREdFLCBGSUxURVJfTkVBUkVTVCwgUElYRUxGT1JNQVRfREVQVEgsIFBJWEVMRk9STUFUX0RFUFRIU1RFTkNJTCwgUElYRUxGT1JNQVRfUjMyRiB9IGZyb20gXCIuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IERlYnVnR3JhcGhpY3MgfSBmcm9tIFwiLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvZGVidWctZ3JhcGhpY3MuanNcIjtcbmltcG9ydCB7IFJlbmRlclBhc3MgfSBmcm9tIFwiLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvcmVuZGVyLXBhc3MuanNcIjtcbmltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gXCIuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9yZW5kZXItdGFyZ2V0LmpzXCI7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIi4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3RleHR1cmUuanNcIjtcblxuLy8gdW5pZm9ybSBuYW1lcyAoZmlyc3QgaXMgY3VycmVudCBuYW1lLCBzZWNvbmQgb25lIGlzIGRlcHJlY2F0ZWQgbmFtZSBmb3IgY29tcGF0aWJpbGl0eSlcbmNvbnN0IF9kZXB0aFVuaWZvcm1OYW1lcyA9IFsndVNjZW5lRGVwdGhNYXAnLCAndURlcHRoTWFwJ107XG5cbi8qKlxuICogQSByZW5kZXIgcGFzcyBpbXBsZW1lbnRpbmcgZ3JhYiBvZiBhIGRlcHRoIGJ1ZmZlciwgdXNlZCBvbiBXZWJHTCAyIGFuZCBXZWJHUFUgZGV2aWNlcy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIFJlbmRlclBhc3NEZXB0aEdyYWIgZXh0ZW5kcyBSZW5kZXJQYXNzIHtcbiAgICBkZXB0aFJlbmRlclRhcmdldCA9IG51bGw7XG5cbiAgICBjYW1lcmEgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoZGV2aWNlLCBjYW1lcmEpIHtcbiAgICAgICAgc3VwZXIoZGV2aWNlKTtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbGVhc2VSZW5kZXJUYXJnZXQodGhpcy5kZXB0aFJlbmRlclRhcmdldCk7XG4gICAgfVxuXG4gICAgc2hvdWxkUmVhbGxvY2F0ZSh0YXJnZXRSVCwgc291cmNlVGV4dHVyZSkge1xuXG4gICAgICAgIC8vIG5lZWQgdG8gcmVhbGxvY2F0ZSBpZiBkaW1lbnNpb25zIGRvbid0IG1hdGNoXG4gICAgICAgIGNvbnN0IHdpZHRoID0gc291cmNlVGV4dHVyZT8ud2lkdGggfHwgdGhpcy5kZXZpY2Uud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZVRleHR1cmU/LmhlaWdodCB8fCB0aGlzLmRldmljZS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiAhdGFyZ2V0UlQgfHwgd2lkdGggIT09IHRhcmdldFJULndpZHRoIHx8IGhlaWdodCAhPT0gdGFyZ2V0UlQuaGVpZ2h0O1xuICAgIH1cblxuICAgIGFsbG9jYXRlUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgc291cmNlUmVuZGVyVGFyZ2V0LCBkZXZpY2UsIGZvcm1hdCwgaXNEZXB0aCkge1xuXG4gICAgICAgIC8vIGFsbG9jYXRlIHRleHR1cmUgYnVmZmVyXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShkZXZpY2UsIHtcbiAgICAgICAgICAgIG5hbWU6IF9kZXB0aFVuaWZvcm1OYW1lc1swXSxcbiAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgIHdpZHRoOiBzb3VyY2VSZW5kZXJUYXJnZXQgPyBzb3VyY2VSZW5kZXJUYXJnZXQuY29sb3JCdWZmZXIud2lkdGggOiBkZXZpY2Uud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNvdXJjZVJlbmRlclRhcmdldCA/IHNvdXJjZVJlbmRlclRhcmdldC5jb2xvckJ1ZmZlci5oZWlnaHQgOiBkZXZpY2UuaGVpZ2h0LFxuICAgICAgICAgICAgbWlwbWFwczogZmFsc2UsXG4gICAgICAgICAgICBtaW5GaWx0ZXI6IEZJTFRFUl9ORUFSRVNULFxuICAgICAgICAgICAgbWFnRmlsdGVyOiBGSUxURVJfTkVBUkVTVCxcbiAgICAgICAgICAgIGFkZHJlc3NVOiBBRERSRVNTX0NMQU1QX1RPX0VER0UsXG4gICAgICAgICAgICBhZGRyZXNzVjogQUREUkVTU19DTEFNUF9UT19FREdFXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXQpIHtcblxuICAgICAgICAgICAgLy8gaWYgcmVhbGxvY2F0aW5nIFJUIHNpemUsIHJlbGVhc2UgcHJldmlvdXMgZnJhbWVidWZmZXJcbiAgICAgICAgICAgIHJlbmRlclRhcmdldC5kZXN0cm95RnJhbWVCdWZmZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIGFzc2lnbiBuZXcgdGV4dHVyZVxuICAgICAgICAgICAgaWYgKGlzRGVwdGgpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXQuX2RlcHRoQnVmZmVyID0gdGV4dHVyZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0Ll9jb2xvckJ1ZmZlciA9IHRleHR1cmU7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0Ll9jb2xvckJ1ZmZlcnMgPSBbdGV4dHVyZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyByZW5kZXIgdGFyZ2V0IHdpdGggdGhlIHRleHR1cmVcbiAgICAgICAgICAgIHJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdEZXB0aEdyYWJSVCcsXG4gICAgICAgICAgICAgICAgY29sb3JCdWZmZXI6IGlzRGVwdGggPyBudWxsIDogdGV4dHVyZSxcbiAgICAgICAgICAgICAgICBkZXB0aEJ1ZmZlcjogaXNEZXB0aCA/IHRleHR1cmUgOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlcHRoOiAhaXNEZXB0aCxcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiBkZXZpY2Uuc3VwcG9ydHNTdGVuY2lsLFxuICAgICAgICAgICAgICAgIGF1dG9SZXNvbHZlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xuICAgIH1cblxuICAgIHJlbGVhc2VSZW5kZXJUYXJnZXQocnQpIHtcblxuICAgICAgICBpZiAocnQpIHtcbiAgICAgICAgICAgIHJ0LmRlc3Ryb3lUZXh0dXJlQnVmZmVycygpO1xuICAgICAgICAgICAgcnQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmVmb3JlKCkge1xuXG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25SdCA9IGNhbWVyYT8ucmVuZGVyVGFyZ2V0ID8/IGRldmljZS5iYWNrQnVmZmVyO1xuXG4gICAgICAgIGxldCB1c2VEZXB0aEJ1ZmZlciA9IHRydWU7XG4gICAgICAgIGxldCBmb3JtYXQgPSBkZXN0aW5hdGlvblJ0LnN0ZW5jaWwgPyBQSVhFTEZPUk1BVF9ERVBUSFNURU5DSUwgOiBQSVhFTEZPUk1BVF9ERVBUSDtcbiAgICAgICAgaWYgKGRldmljZS5pc1dlYkdQVSkge1xuICAgICAgICAgICAgY29uc3QgbnVtU2FtcGxlcyA9IGRlc3RpbmF0aW9uUnQuc2FtcGxlcztcblxuICAgICAgICAgICAgLy8gd2hlbiBkZXB0aCBidWZmZXIgaXMgbXVsdGktc2FtcGxlZCwgaW5zdGVhZCBvZiBjb3B5aW5nIGl0IG91dCwgd2UgdXNlIGN1c3RvbSBzaGFkZXIgdG8gcmVzb2x2ZSBpdFxuICAgICAgICAgICAgLy8gdG8gYSBSMzJGIHRleHR1cmUsIHVzZWQgYXMgYSBjb2xvciBhdHRhY2htZW50IG9mIHRoZSByZW5kZXIgdGFyZ2V0XG4gICAgICAgICAgICBpZiAobnVtU2FtcGxlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBQSVhFTEZPUk1BVF9SMzJGO1xuICAgICAgICAgICAgICAgIHVzZURlcHRoQnVmZmVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzb3VyY2VUZXh0dXJlID0gY2FtZXJhLnJlbmRlclRhcmdldD8uZGVwdGhCdWZmZXIgPz8gY2FtZXJhLnJlbmRlclRhcmdldD8uY29sb3JCdWZmZXI7XG5cbiAgICAgICAgLy8gYWxsb2NhdGUgLyByZXNpemUgZXhpc3RpbmcgUlQgYXMgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlYWxsb2NhdGUodGhpcy5kZXB0aFJlbmRlclRhcmdldCwgc291cmNlVGV4dHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZVJlbmRlclRhcmdldCh0aGlzLmRlcHRoUmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhSZW5kZXJUYXJnZXQgPSB0aGlzLmFsbG9jYXRlUmVuZGVyVGFyZ2V0KHRoaXMuZGVwdGhSZW5kZXJUYXJnZXQsIGNhbWVyYS5yZW5kZXJUYXJnZXQsIGRldmljZSwgZm9ybWF0LCB1c2VEZXB0aEJ1ZmZlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhc3NpZ24gdW5pZm9ybVxuICAgICAgICBjb25zdCBjb2xvckJ1ZmZlciA9IHVzZURlcHRoQnVmZmVyID8gdGhpcy5kZXB0aFJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA6IHRoaXMuZGVwdGhSZW5kZXJUYXJnZXQuY29sb3JCdWZmZXI7XG4gICAgICAgIF9kZXB0aFVuaWZvcm1OYW1lcy5mb3JFYWNoKG5hbWUgPT4gZGV2aWNlLnNjb3BlLnJlc29sdmUobmFtZSkuc2V0VmFsdWUoY29sb3JCdWZmZXIpKTtcbiAgICB9XG5cbiAgICBleGVjdXRlKCkge1xuXG4gICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMuZGV2aWNlO1xuICAgICAgICBEZWJ1Z0dyYXBoaWNzLnB1c2hHcHVNYXJrZXIoZGV2aWNlLCAnR1JBQi1ERVBUSCcpO1xuXG4gICAgICAgIC8vIFdlYkdMMiBtdWx0aXNhbXBsaW5nIGRlcHRoIGhhbmRsaW5nOiB3ZSByZXNvbHZlIG11bHRpLXNhbXBsZWQgZGVwdGggYnVmZmVyIHRvIGEgc2luZ2xlLXNhbXBsZWQgZGVzdGluYXRpb24gYnVmZmVyLlxuICAgICAgICAvLyBXZSBjb3VsZCB1c2UgZXhpc3RpbmcgQVBJIGFuZCByZXNvbHZlIGRlcHRoIGZpcnN0IGFuZCB0aGVuIGJsaXQgaXQgdG8gZGVzdGluYXRpb24sIGJ1dCB0aGlzIGF2b2lkcyB0aGUgZXh0cmEgY29weS5cbiAgICAgICAgaWYgKGRldmljZS5pc1dlYkdMMiAmJiBkZXZpY2UucmVuZGVyVGFyZ2V0LnNhbXBsZXMgPiAxKSB7XG5cbiAgICAgICAgICAgIC8vIG11bHRpLXNhbXBsZWQgYnVmZmVyXG4gICAgICAgICAgICBjb25zdCBzcmMgPSBkZXZpY2UucmVuZGVyVGFyZ2V0LmltcGwuX2dsRnJhbWVCdWZmZXI7XG5cbiAgICAgICAgICAgIC8vIHNpbmdsZSBzYW1wbGVkIGRlc3RpbmF0aW9uIGJ1ZmZlclxuICAgICAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMuZGVwdGhSZW5kZXJUYXJnZXQ7XG4gICAgICAgICAgICBkZXZpY2UucmVuZGVyVGFyZ2V0ID0gZGVzdDtcbiAgICAgICAgICAgIGRldmljZS51cGRhdGVCZWdpbigpO1xuXG4gICAgICAgICAgICB0aGlzLmRlcHRoUmVuZGVyVGFyZ2V0LmltcGwuaW50ZXJuYWxSZXNvbHZlKGRldmljZSwgc3JjLCBkZXN0LmltcGwuX2dsRnJhbWVCdWZmZXIsIHRoaXMuZGVwdGhSZW5kZXJUYXJnZXQsIGRldmljZS5nbC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBjb3B5IGRlcHRoXG4gICAgICAgICAgICBkZXZpY2UuY29weVJlbmRlclRhcmdldChkZXZpY2UucmVuZGVyVGFyZ2V0LCB0aGlzLmRlcHRoUmVuZGVyVGFyZ2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBEZWJ1Z0dyYXBoaWNzLnBvcEdwdU1hcmtlcihkZXZpY2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUmVuZGVyUGFzc0RlcHRoR3JhYiB9O1xuIl0sIm5hbWVzIjpbIl9kZXB0aFVuaWZvcm1OYW1lcyIsIlJlbmRlclBhc3NEZXB0aEdyYWIiLCJSZW5kZXJQYXNzIiwiY29uc3RydWN0b3IiLCJkZXZpY2UiLCJjYW1lcmEiLCJkZXB0aFJlbmRlclRhcmdldCIsImRlc3Ryb3kiLCJyZWxlYXNlUmVuZGVyVGFyZ2V0Iiwic2hvdWxkUmVhbGxvY2F0ZSIsInRhcmdldFJUIiwic291cmNlVGV4dHVyZSIsIndpZHRoIiwiaGVpZ2h0IiwiYWxsb2NhdGVSZW5kZXJUYXJnZXQiLCJyZW5kZXJUYXJnZXQiLCJzb3VyY2VSZW5kZXJUYXJnZXQiLCJmb3JtYXQiLCJpc0RlcHRoIiwidGV4dHVyZSIsIlRleHR1cmUiLCJuYW1lIiwiY29sb3JCdWZmZXIiLCJtaXBtYXBzIiwibWluRmlsdGVyIiwiRklMVEVSX05FQVJFU1QiLCJtYWdGaWx0ZXIiLCJhZGRyZXNzVSIsIkFERFJFU1NfQ0xBTVBfVE9fRURHRSIsImFkZHJlc3NWIiwiZGVzdHJveUZyYW1lQnVmZmVycyIsIl9kZXB0aEJ1ZmZlciIsIl9jb2xvckJ1ZmZlciIsIl9jb2xvckJ1ZmZlcnMiLCJSZW5kZXJUYXJnZXQiLCJkZXB0aEJ1ZmZlciIsImRlcHRoIiwic3RlbmNpbCIsInN1cHBvcnRzU3RlbmNpbCIsImF1dG9SZXNvbHZlIiwicnQiLCJkZXN0cm95VGV4dHVyZUJ1ZmZlcnMiLCJiZWZvcmUiLCJfY2FtZXJhJHJlbmRlclRhcmdldCIsIl9jYW1lcmEkcmVuZGVyVGFyZ2V0JCIsIl9jYW1lcmEkcmVuZGVyVGFyZ2V0MiIsIl9jYW1lcmEkcmVuZGVyVGFyZ2V0MyIsImRlc3RpbmF0aW9uUnQiLCJiYWNrQnVmZmVyIiwidXNlRGVwdGhCdWZmZXIiLCJQSVhFTEZPUk1BVF9ERVBUSFNURU5DSUwiLCJQSVhFTEZPUk1BVF9ERVBUSCIsImlzV2ViR1BVIiwibnVtU2FtcGxlcyIsInNhbXBsZXMiLCJQSVhFTEZPUk1BVF9SMzJGIiwiZm9yRWFjaCIsInNjb3BlIiwicmVzb2x2ZSIsInNldFZhbHVlIiwiZXhlY3V0ZSIsIkRlYnVnR3JhcGhpY3MiLCJwdXNoR3B1TWFya2VyIiwiaXNXZWJHTDIiLCJzcmMiLCJpbXBsIiwiX2dsRnJhbWVCdWZmZXIiLCJkZXN0IiwidXBkYXRlQmVnaW4iLCJpbnRlcm5hbFJlc29sdmUiLCJnbCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJjb3B5UmVuZGVyVGFyZ2V0IiwicG9wR3B1TWFya2VyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFNQTtBQUNBLE1BQU1BLGtCQUFrQixHQUFHLENBQUMsZ0JBQWdCLEVBQUUsV0FBVyxDQUFDLENBQUE7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxtQkFBbUIsU0FBU0MsVUFBVSxDQUFDO0FBS3pDQyxFQUFBQSxXQUFXQSxDQUFDQyxNQUFNLEVBQUVDLE1BQU0sRUFBRTtJQUN4QixLQUFLLENBQUNELE1BQU0sQ0FBQyxDQUFBO0lBQUMsSUFMbEJFLENBQUFBLGlCQUFpQixHQUFHLElBQUksQ0FBQTtJQUFBLElBRXhCRCxDQUFBQSxNQUFNLEdBQUcsSUFBSSxDQUFBO0lBSVQsSUFBSSxDQUFDQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQTtBQUN4QixHQUFBO0FBRUFFLEVBQUFBLE9BQU9BLEdBQUc7SUFDTixLQUFLLENBQUNBLE9BQU8sRUFB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
