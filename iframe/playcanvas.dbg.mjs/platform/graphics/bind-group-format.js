import { TRACEID_BINDGROUPFORMAT_ALLOC } from '../../core/constants.js';
import { DebugHelper, Debug } from '../../core/debug.js';
import { TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT, PIXELFORMAT_RGBA8, SAMPLETYPE_INT, SAMPLETYPE_UINT, TEXTUREDIMENSION_CUBE, TEXTUREDIMENSION_3D, TEXTUREDIMENSION_2D_ARRAY } from './constants.js';

let id = 0;
const textureDimensionInfo = {
  [TEXTUREDIMENSION_2D]: 'texture2D',
  [TEXTUREDIMENSION_CUBE]: 'textureCube',
  [TEXTUREDIMENSION_3D]: 'texture3D',
  [TEXTUREDIMENSION_2D_ARRAY]: 'texture2DArray'
};

/**
 * @ignore
 */
class BindBufferFormat {
  constructor(name, visibility) {
    /** @type {string} */
    this.name = name;

    // SHADERSTAGE_VERTEX, SHADERSTAGE_FRAGMENT, SHADERSTAGE_COMPUTE
    this.visibility = visibility;
  }
}

/**
 * @ignore
 */
class BindTextureFormat {
  constructor(name, visibility, textureDimension = TEXTUREDIMENSION_2D, sampleType = SAMPLETYPE_FLOAT) {
    /** @type {import('./scope-id.js').ScopeId} */
    this.scopeId = void 0;
    /** @type {string} */
    this.name = name;

    // SHADERSTAGE_VERTEX, SHADERSTAGE_FRAGMENT, SHADERSTAGE_COMPUTE
    this.visibility = visibility;

    // TEXTUREDIMENSION_***
    this.textureDimension = textureDimension;

    // SAMPLETYPE_***
    this.sampleType = sampleType;
  }
}

/**
 * @ignore
 */
class BindStorageTextureFormat {
  constructor(name, format = PIXELFORMAT_RGBA8, textureDimension = TEXTUREDIMENSION_2D) {
    /** @type {import('./scope-id.js').ScopeId} */
    this.scopeId = void 0;
    /** @type {string} */
    this.name = name;

    // PIXELFORMAT_***
    this.format = format;

    // TEXTUREDIMENSION_***
    this.textureDimension = textureDimension;
  }
}

/**
 * @ignore
 */
class BindGroupFormat {
  /**
   * @param {import('./graphics-device.js').GraphicsDevice} graphicsDevice - The graphics device
   * used to manage this vertex format.
   * @param {BindBufferFormat[]} [bufferFormats] - An array of bind buffer formats (uniform
   * buffers). Defaults to an empty array.
   * @param {BindTextureFormat[]} [textureFormats] - An array of bind texture formats (textures).
   * Defaults to an empty array.
   * @param {BindStorageTextureFormat[]} [storageTextureFormats] - An array of bind storage texture
   * formats (storage textures), used by the compute shader. Defaults to an empty array.
   * @param {object} [options] - Object for passing optional arguments.
   * @param {boolean} [options.compute] - If true, this bind group format is used by the compute
   * shader.
   */
  constructor(graphicsDevice, bufferFormats = [], textureFormats = [], storageTextureFormats = [], options = {}) {
    var _options$compute;
    this.compute = false;
    this.id = id++;
    DebugHelper.setName(this, `BindGroupFormat_${this.id}`);
    this.compute = (_options$compute = options.compute) != null ? _options$compute : false;
    Debug.assert(this.compute || storageTextureFormats.length === 0, "Storage textures can be specified only for compute");

    /** @type {import('./graphics-device.js').GraphicsDevice} */
    this.device = graphicsDevice;
    const scope = graphicsDevice.scope;

    /** @type {BindBufferFormat[]} */
    this.bufferFormats = bufferFormats;

    // maps a buffer format name to an index
    /** @type {Map<string, number>} */
    this.bufferFormatsMap = new Map();
    bufferFormats.forEach((bf, i) => this.bufferFormatsMap.set(bf.name, i));

    /** @type {BindTextureFormat[]} */
    this.textureFormats = textureFormats;

    // maps a texture format name to a slot index
    /** @type {Map<string, number>} */
    this.textureFormatsMap = new Map();
    textureFormats.forEach((tf, i) => {
      this.textureFormatsMap.set(tf.name, i);

      // resolve scope id
      tf.scopeId = scope.resolve(tf.name);
    });

    /** @type {BindStorageTextureFormat[]} */
    this.storageTextureFormats = storageTextureFormats;

    // maps a storage texture format name to a slot index
    /** @type {Map<string, number>} */
    this.storageTextureFormatsMap = new Map();
    storageTextureFormats.forEach((tf, i) => {
      this.storageTextureFormatsMap.set(tf.name, i);

      // resolve scope id
      tf.scopeId = scope.resolve(tf.name);
    });
    this.impl = graphicsDevice.createBindGroupFormatImpl(this);
    Debug.trace(TRACEID_BINDGROUPFORMAT_ALLOC, `Alloc: Id ${this.id}`, this);
  }

  /**
   * Frees resources associated with this bind group.
   */
  destroy() {
    this.impl.destroy();
  }

  /**
   * Returns format of texture with specified name.
   *
   * @param {string} name - The name of the texture slot.
   * @returns {BindTextureFormat|null} - The format.
   */
  getTexture(name) {
    const index = this.textureFormatsMap.get(name);
    if (index !== undefined) {
      return this.textureFormats[index];
    }
    return null;
  }

  /**
   * Returns format of storage texture with specified name.
   *
   * @param {string} name - The name of the texture slot.
   * @returns {BindStorageTextureFormat|null} - The format.
   */
  getStorageTexture(name) {
    const index = this.storageTextureFormatsMap.get(name);
    if (index !== undefined) {
      return this.storageTextureFormats[index];
    }
    return null;
  }
  getShaderDeclarationTextures(bindGroup) {
    let code = '';
    let bindIndex = this.bufferFormats.length;
    this.textureFormats.forEach(format => {
      let textureType = textureDimensionInfo[format.textureDimension];
      Debug.assert(textureType, "Unsupported texture type", format.textureDimension);

      // handle texture2DArray by renaming the texture object and defining a replacement macro
      let namePostfix = '';
      let extraCode = '';
      if (textureType === 'texture2DArray') {
        namePostfix = '_texture';
        extraCode = `#define ${format.name} sampler2DArray(${format.name}${namePostfix}, ${format.name}_sampler)\n`;
      }
      if (format.sampleType === SAMPLETYPE_INT) {
        textureType = `i${textureType}`;
      } else if (format.sampleType === SAMPLETYPE_UINT) {
        textureType = `u${textureType}`;
      }
      code += `layout(set = ${bindGroup}, binding = ${bindIndex++}) uniform ${textureType} ${format.name}${namePostfix};\n` + `layout(set = ${bindGroup}, binding = ${bindIndex++}) uniform sampler ${format.name}_sampler;\n` + extraCode;
    });
    return code;
  }
  loseContext() {
    // TODO: implement
  }
}

export { BindBufferFormat, BindGroupFormat, BindStorageTextureFormat, BindTextureFormat };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmluZC1ncm91cC1mb3JtYXQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9wbGF0Zm9ybS9ncmFwaGljcy9iaW5kLWdyb3VwLWZvcm1hdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUUkFDRUlEX0JJTkRHUk9VUEZPUk1BVF9BTExPQyB9IGZyb20gJy4uLy4uL2NvcmUvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IERlYnVnLCBEZWJ1Z0hlbHBlciB9IGZyb20gJy4uLy4uL2NvcmUvZGVidWcuanMnO1xuXG5pbXBvcnQge1xuICAgIFRFWFRVUkVESU1FTlNJT05fMkQsIFRFWFRVUkVESU1FTlNJT05fQ1VCRSwgVEVYVFVSRURJTUVOU0lPTl8zRCwgVEVYVFVSRURJTUVOU0lPTl8yRF9BUlJBWSxcbiAgICBTQU1QTEVUWVBFX0ZMT0FULCBQSVhFTEZPUk1BVF9SR0JBOCwgU0FNUExFVFlQRV9JTlQsIFNBTVBMRVRZUEVfVUlOVFxufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbmxldCBpZCA9IDA7XG5cbmNvbnN0IHRleHR1cmVEaW1lbnNpb25JbmZvID0ge1xuICAgIFtURVhUVVJFRElNRU5TSU9OXzJEXTogJ3RleHR1cmUyRCcsXG4gICAgW1RFWFRVUkVESU1FTlNJT05fQ1VCRV06ICd0ZXh0dXJlQ3ViZScsXG4gICAgW1RFWFRVUkVESU1FTlNJT05fM0RdOiAndGV4dHVyZTNEJyxcbiAgICBbVEVYVFVSRURJTUVOU0lPTl8yRF9BUlJBWV06ICd0ZXh0dXJlMkRBcnJheSdcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jbGFzcyBCaW5kQnVmZmVyRm9ybWF0IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2aXNpYmlsaXR5KSB7XG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIFNIQURFUlNUQUdFX1ZFUlRFWCwgU0hBREVSU1RBR0VfRlJBR01FTlQsIFNIQURFUlNUQUdFX0NPTVBVVEVcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICB9XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jbGFzcyBCaW5kVGV4dHVyZUZvcm1hdCB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vc2NvcGUtaWQuanMnKS5TY29wZUlkfSAqL1xuICAgIHNjb3BlSWQ7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2aXNpYmlsaXR5LCB0ZXh0dXJlRGltZW5zaW9uID0gVEVYVFVSRURJTUVOU0lPTl8yRCwgc2FtcGxlVHlwZSA9IFNBTVBMRVRZUEVfRkxPQVQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gU0hBREVSU1RBR0VfVkVSVEVYLCBTSEFERVJTVEFHRV9GUkFHTUVOVCwgU0hBREVSU1RBR0VfQ09NUFVURVxuICAgICAgICB0aGlzLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5O1xuXG4gICAgICAgIC8vIFRFWFRVUkVESU1FTlNJT05fKioqXG4gICAgICAgIHRoaXMudGV4dHVyZURpbWVuc2lvbiA9IHRleHR1cmVEaW1lbnNpb247XG5cbiAgICAgICAgLy8gU0FNUExFVFlQRV8qKipcbiAgICAgICAgdGhpcy5zYW1wbGVUeXBlID0gc2FtcGxlVHlwZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jbGFzcyBCaW5kU3RvcmFnZVRleHR1cmVGb3JtYXQge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3Njb3BlLWlkLmpzJykuU2NvcGVJZH0gKi9cbiAgICBzY29wZUlkO1xuXG4gICAgY29uc3RydWN0b3IobmFtZSwgZm9ybWF0ID0gUElYRUxGT1JNQVRfUkdCQTgsIHRleHR1cmVEaW1lbnNpb24gPSBURVhUVVJFRElNRU5TSU9OXzJEKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIFBJWEVMRk9STUFUXyoqKlxuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblxuICAgICAgICAvLyBURVhUVVJFRElNRU5TSU9OXyoqKlxuICAgICAgICB0aGlzLnRleHR1cmVEaW1lbnNpb24gPSB0ZXh0dXJlRGltZW5zaW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIEJpbmRHcm91cEZvcm1hdCB7XG4gICAgY29tcHV0ZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4vZ3JhcGhpY3MtZGV2aWNlLmpzJykuR3JhcGhpY3NEZXZpY2V9IGdyYXBoaWNzRGV2aWNlIC0gVGhlIGdyYXBoaWNzIGRldmljZVxuICAgICAqIHVzZWQgdG8gbWFuYWdlIHRoaXMgdmVydGV4IGZvcm1hdC5cbiAgICAgKiBAcGFyYW0ge0JpbmRCdWZmZXJGb3JtYXRbXX0gW2J1ZmZlckZvcm1hdHNdIC0gQW4gYXJyYXkgb2YgYmluZCBidWZmZXIgZm9ybWF0cyAodW5pZm9ybVxuICAgICAqIGJ1ZmZlcnMpLiBEZWZhdWx0cyB0byBhbiBlbXB0eSBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0JpbmRUZXh0dXJlRm9ybWF0W119IFt0ZXh0dXJlRm9ybWF0c10gLSBBbiBhcnJheSBvZiBiaW5kIHRleHR1cmUgZm9ybWF0cyAodGV4dHVyZXMpLlxuICAgICAqIERlZmF1bHRzIHRvIGFuIGVtcHR5IGFycmF5LlxuICAgICAqIEBwYXJhbSB7QmluZFN0b3JhZ2VUZXh0dXJlRm9ybWF0W119IFtzdG9yYWdlVGV4dHVyZUZvcm1hdHNdIC0gQW4gYXJyYXkgb2YgYmluZCBzdG9yYWdlIHRleHR1cmVcbiAgICAgKiBmb3JtYXRzIChzdG9yYWdlIHRleHR1cmVzKSwgdXNlZCBieSB0aGUgY29tcHV0ZSBzaGFkZXIuIERlZmF1bHRzIHRvIGFuIGVtcHR5IGFycmF5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPYmplY3QgZm9yIHBhc3Npbmcgb3B0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29tcHV0ZV0gLSBJZiB0cnVlLCB0aGlzIGJpbmQgZ3JvdXAgZm9ybWF0IGlzIHVzZWQgYnkgdGhlIGNvbXB1dGVcbiAgICAgKiBzaGFkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3JhcGhpY3NEZXZpY2UsIGJ1ZmZlckZvcm1hdHMgPSBbXSwgdGV4dHVyZUZvcm1hdHMgPSBbXSwgc3RvcmFnZVRleHR1cmVGb3JtYXRzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmlkID0gaWQrKztcbiAgICAgICAgRGVidWdIZWxwZXIuc2V0TmFtZSh0aGlzLCBgQmluZEdyb3VwRm9ybWF0XyR7dGhpcy5pZH1gKTtcblxuICAgICAgICB0aGlzLmNvbXB1dGUgPSBvcHRpb25zLmNvbXB1dGUgPz8gZmFsc2U7XG4gICAgICAgIERlYnVnLmFzc2VydCh0aGlzLmNvbXB1dGUgfHwgc3RvcmFnZVRleHR1cmVGb3JtYXRzLmxlbmd0aCA9PT0gMCwgXCJTdG9yYWdlIHRleHR1cmVzIGNhbiBiZSBzcGVjaWZpZWQgb25seSBmb3IgY29tcHV0ZVwiKTtcblxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9ncmFwaGljcy1kZXZpY2UuanMnKS5HcmFwaGljc0RldmljZX0gKi9cbiAgICAgICAgdGhpcy5kZXZpY2UgPSBncmFwaGljc0RldmljZTtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBncmFwaGljc0RldmljZS5zY29wZTtcblxuICAgICAgICAvKiogQHR5cGUge0JpbmRCdWZmZXJGb3JtYXRbXX0gKi9cbiAgICAgICAgdGhpcy5idWZmZXJGb3JtYXRzID0gYnVmZmVyRm9ybWF0cztcblxuICAgICAgICAvLyBtYXBzIGEgYnVmZmVyIGZvcm1hdCBuYW1lIHRvIGFuIGluZGV4XG4gICAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgICAgICAgdGhpcy5idWZmZXJGb3JtYXRzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBidWZmZXJGb3JtYXRzLmZvckVhY2goKGJmLCBpKSA9PiB0aGlzLmJ1ZmZlckZvcm1hdHNNYXAuc2V0KGJmLm5hbWUsIGkpKTtcblxuICAgICAgICAvKiogQHR5cGUge0JpbmRUZXh0dXJlRm9ybWF0W119ICovXG4gICAgICAgIHRoaXMudGV4dHVyZUZvcm1hdHMgPSB0ZXh0dXJlRm9ybWF0cztcblxuICAgICAgICAvLyBtYXBzIGEgdGV4dHVyZSBmb3JtYXQgbmFtZSB0byBhIHNsb3QgaW5kZXhcbiAgICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuICAgICAgICB0aGlzLnRleHR1cmVGb3JtYXRzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0ZXh0dXJlRm9ybWF0cy5mb3JFYWNoKCh0ZiwgaSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRm9ybWF0c01hcC5zZXQodGYubmFtZSwgaSk7XG5cbiAgICAgICAgICAgIC8vIHJlc29sdmUgc2NvcGUgaWRcbiAgICAgICAgICAgIHRmLnNjb3BlSWQgPSBzY29wZS5yZXNvbHZlKHRmLm5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiogQHR5cGUge0JpbmRTdG9yYWdlVGV4dHVyZUZvcm1hdFtdfSAqL1xuICAgICAgICB0aGlzLnN0b3JhZ2VUZXh0dXJlRm9ybWF0cyA9IHN0b3JhZ2VUZXh0dXJlRm9ybWF0cztcblxuICAgICAgICAvLyBtYXBzIGEgc3RvcmFnZSB0ZXh0dXJlIGZvcm1hdCBuYW1lIHRvIGEgc2xvdCBpbmRleFxuICAgICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59ICovXG4gICAgICAgIHRoaXMuc3RvcmFnZVRleHR1cmVGb3JtYXRzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBzdG9yYWdlVGV4dHVyZUZvcm1hdHMuZm9yRWFjaCgodGYsIGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZVRleHR1cmVGb3JtYXRzTWFwLnNldCh0Zi5uYW1lLCBpKTtcblxuICAgICAgICAgICAgLy8gcmVzb2x2ZSBzY29wZSBpZFxuICAgICAgICAgICAgdGYuc2NvcGVJZCA9IHNjb3BlLnJlc29sdmUodGYubmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW1wbCA9IGdyYXBoaWNzRGV2aWNlLmNyZWF0ZUJpbmRHcm91cEZvcm1hdEltcGwodGhpcyk7XG5cbiAgICAgICAgRGVidWcudHJhY2UoVFJBQ0VJRF9CSU5ER1JPVVBGT1JNQVRfQUxMT0MsIGBBbGxvYzogSWQgJHt0aGlzLmlkfWAsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZyZWVzIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBiaW5kIGdyb3VwLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaW1wbC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmb3JtYXQgb2YgdGV4dHVyZSB3aXRoIHNwZWNpZmllZCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGV4dHVyZSBzbG90LlxuICAgICAqIEByZXR1cm5zIHtCaW5kVGV4dHVyZUZvcm1hdHxudWxsfSAtIFRoZSBmb3JtYXQuXG4gICAgICovXG4gICAgZ2V0VGV4dHVyZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50ZXh0dXJlRm9ybWF0c01hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlRm9ybWF0c1tpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZvcm1hdCBvZiBzdG9yYWdlIHRleHR1cmUgd2l0aCBzcGVjaWZpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRleHR1cmUgc2xvdC5cbiAgICAgKiBAcmV0dXJucyB7QmluZFN0b3JhZ2VUZXh0dXJlRm9ybWF0fG51bGx9IC0gVGhlIGZvcm1hdC5cbiAgICAgKi9cbiAgICBnZXRTdG9yYWdlVGV4dHVyZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdG9yYWdlVGV4dHVyZUZvcm1hdHNNYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVRleHR1cmVGb3JtYXRzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGdldFNoYWRlckRlY2xhcmF0aW9uVGV4dHVyZXMoYmluZEdyb3VwKSB7XG4gICAgICAgIGxldCBjb2RlID0gJyc7XG4gICAgICAgIGxldCBiaW5kSW5kZXggPSB0aGlzLmJ1ZmZlckZvcm1hdHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnRleHR1cmVGb3JtYXRzLmZvckVhY2goKGZvcm1hdCkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgdGV4dHVyZVR5cGUgPSB0ZXh0dXJlRGltZW5zaW9uSW5mb1tmb3JtYXQudGV4dHVyZURpbWVuc2lvbl07XG4gICAgICAgICAgICBEZWJ1Zy5hc3NlcnQodGV4dHVyZVR5cGUsIFwiVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlXCIsIGZvcm1hdC50ZXh0dXJlRGltZW5zaW9uKTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIHRleHR1cmUyREFycmF5IGJ5IHJlbmFtaW5nIHRoZSB0ZXh0dXJlIG9iamVjdCBhbmQgZGVmaW5pbmcgYSByZXBsYWNlbWVudCBtYWNyb1xuICAgICAgICAgICAgbGV0IG5hbWVQb3N0Zml4ID0gJyc7XG4gICAgICAgICAgICBsZXQgZXh0cmFDb2RlID0gJyc7XG4gICAgICAgICAgICBpZiAodGV4dHVyZVR5cGUgPT09ICd0ZXh0dXJlMkRBcnJheScpIHtcbiAgICAgICAgICAgICAgICBuYW1lUG9zdGZpeCA9ICdfdGV4dHVyZSc7XG4gICAgICAgICAgICAgICAgZXh0cmFDb2RlID0gYCNkZWZpbmUgJHtmb3JtYXQubmFtZX0gc2FtcGxlcjJEQXJyYXkoJHtmb3JtYXQubmFtZX0ke25hbWVQb3N0Zml4fSwgJHtmb3JtYXQubmFtZX1fc2FtcGxlcilcXG5gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0LnNhbXBsZVR5cGUgPT09IFNBTVBMRVRZUEVfSU5UKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZVR5cGUgPSBgaSR7dGV4dHVyZVR5cGV9YDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LnNhbXBsZVR5cGUgPT09IFNBTVBMRVRZUEVfVUlOVCkge1xuICAgICAgICAgICAgICAgIHRleHR1cmVUeXBlID0gYHUke3RleHR1cmVUeXBlfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvZGUgKz0gYGxheW91dChzZXQgPSAke2JpbmRHcm91cH0sIGJpbmRpbmcgPSAke2JpbmRJbmRleCsrfSkgdW5pZm9ybSAke3RleHR1cmVUeXBlfSAke2Zvcm1hdC5uYW1lfSR7bmFtZVBvc3RmaXh9O1xcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgbGF5b3V0KHNldCA9ICR7YmluZEdyb3VwfSwgYmluZGluZyA9ICR7YmluZEluZGV4Kyt9KSB1bmlmb3JtIHNhbXBsZXIgJHtmb3JtYXQubmFtZX1fc2FtcGxlcjtcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFDb2RlO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cblxuICAgIGxvc2VDb250ZXh0KCkge1xuICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnRcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJpbmRCdWZmZXJGb3JtYXQsIEJpbmRUZXh0dXJlRm9ybWF0LCBCaW5kR3JvdXBGb3JtYXQsIEJpbmRTdG9yYWdlVGV4dHVyZUZvcm1hdCB9O1xuIl0sIm5hbWVzIjpbImlkIiwidGV4dHVyZURpbWVuc2lvbkluZm8iLCJURVhUVVJFRElNRU5TSU9OXzJEIiwiVEVYVFVSRURJTUVOU0lPTl9DVUJFIiwiVEVYVFVSRURJTUVOU0lPTl8zRCIsIlRFWFRVUkVESU1FTlNJT05fMkRfQVJSQVkiLCJCaW5kQnVmZmVyRm9ybWF0IiwiY29uc3RydWN0b3IiLCJuYW1lIiwidmlzaWJpbGl0eSIsIkJpbmRUZXh0dXJlRm9ybWF0IiwidGV4dHVyZURpbWVuc2lvbiIsInNhbXBsZVR5cGUiLCJTQU1QTEVUWVBFX0ZMT0FUIiwic2NvcGVJZCIsIkJpbmRTdG9yYWdlVGV4dHVyZUZvcm1hdCIsImZvcm1hdCIsIlBJWEVMRk9STUFUX1JHQkE4IiwiQmluZEdyb3VwRm9ybWF0IiwiZ3JhcGhpY3NEZXZpY2UiLCJidWZmZXJGb3JtYXRzIiwidGV4dHVyZUZvcm1hdHMiLCJzdG9yYWdlVGV4dHVyZUZvcm1hdHMiLCJvcHRpb25zIiwiX29wdGlvbnMkY29tcHV0ZSIsImNvbXB1dGUiLCJEZWJ1Z0hlbHBlciIsInNldE5hbWUiLCJEZWJ1ZyIsImFzc2VydCIsImxlbmd0aCIsImRldmljZSIsInNjb3BlIiwiYnVmZmVyRm9ybWF0c01hcCIsIk1hcCIsImZvckVhY2giLCJiZiIsImkiLCJzZXQiLCJ0ZXh0dXJlRm9ybWF0c01hcCIsInRmIiwicmVzb2x2ZSIsInN0b3JhZ2VUZXh0dXJlRm9ybWF0c01hcCIsImltcGwiLCJjcmVhdGVCaW5kR3JvdXBGb3JtYXRJbXBsIiwidHJhY2UiLCJUUkFDRUlEX0JJTkRHUk9VUEZPUk1BVF9BTExPQyIsImRlc3Ryb3kiLCJnZXRUZXh0dXJlIiwiaW5kZXgiLCJnZXQiLCJ1bmRlZmluZWQiLCJnZXRTdG9yYWdlVGV4dHVyZSIsImdldFNoYWRlckRlY2xhcmF0aW9uVGV4dHVyZXMiLCJiaW5kR3JvdXAiLCJjb2RlIiwiYmluZEluZGV4IiwidGV4dHVyZVR5cGUiLCJuYW1lUG9zdGZpeCIsImV4dHJhQ29kZSIsIlNBTVBMRVRZUEVfSU5UIiwiU0FNUExFVFlQRV9VSU5UIiwibG9zZUNvbnRleHQiXSwibWFwcGluZ3MiOiI7Ozs7QUFRQSxJQUFJQSxFQUFFLEdBQUcsQ0FBQyxDQUFBO0FBRVYsTUFBTUMsb0JBQW9CLEdBQUc7RUFDekIsQ0FBQ0MsbUJBQW1CLEdBQUcsV0FBVztFQUNsQyxDQUFDQyxxQkFBcUIsR0FBRyxhQUFhO0VBQ3RDLENBQUNDLG1CQUFtQixHQUFHLFdBQVc7QUFDbEMsRUFBQSxDQUFDQyx5QkFBeUIsR0FBRyxnQkFBQTtBQUNqQyxDQUFDLENBQUE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsZ0JBQWdCLENBQUM7QUFDbkJDLEVBQUFBLFdBQVdBLENBQUNDLElBQUksRUFBRUMsVUFBVSxFQUFFO0FBQzFCO0lBQ0EsSUFBSSxDQUFDRCxJQUFJLEdBQUdBLElBQUksQ0FBQTs7QUFFaEI7SUFDQSxJQUFJLENBQUNDLFVBQVUsR0FBR0EsVUFBVSxDQUFBO0FBQ2hDLEdBQUE7QUFDSixDQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLGlCQUFpQixDQUFDO0FBSXBCSCxFQUFBQSxXQUFXQSxDQUFDQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUUsZ0JBQWdCLEdBQUdULG1CQUFtQixFQUFFVSxVQUFVLEdBQUdDLGdCQUFnQixFQUFFO0FBSHJHO0FBQUEsSUFBQSxJQUFBLENBQ0FDLE9BQU8sR0FBQSxLQUFBLENBQUEsQ0FBQTtBQUdIO0lBQ0EsSUFBSSxDQUFDTixJQUFJLEdBQUdBLElBQUksQ0FBQTs7QUFFaEI7SUFDQSxJQUFJLENBQUNDLFVBQVUsR0FBR0EsVUFBVSxDQUFBOztBQUU1QjtJQUNBLElBQUksQ0FBQ0UsZ0JBQWdCLEdBQUdBLGdCQUFnQixDQUFBOztBQUV4QztJQUNBLElBQUksQ0FBQ0MsVUFBVSxHQUFHQSxVQUFVLENBQUE7QUFDaEMsR0FBQTtBQUNKLENBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTUcsd0JBQXdCLENBQUM7RUFJM0JSLFdBQVdBLENBQUNDLElBQUksRUFBRVEsTUFBTSxHQUFHQyxpQkFBaUIsRUFBRU4sZ0JBQWdCLEdBQUdULG1CQUFtQixFQUFFO0FBSHRGO0FBQUEsSUFBQSxJQUFBLENBQ0FZLE9BQU8sR0FBQSxLQUFBLENBQUEsQ0FBQTtBQUdIO0lBQ0EsSUFBSSxDQUFDTixJQUFJLEdBQUdBLElBQUksQ0FBQTs7QUFFaEI7SUFDQSxJQUFJLENBQUNRLE1BQU0sR0FBR0EsTUFBTSxDQUFBOztBQUVwQjtJQUNBLElBQUksQ0FBQ0wsZ0JBQWdCLEdBQUdBLGdCQUFnQixDQUFBO0FBQzVDLEdBQUE7QUFDSixDQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU1PLGVBQWUsQ0FBQztBQUdsQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJWCxFQUFBQSxXQUFXQSxDQUFDWSxjQUFjLEVBQUVDLGFBQWEsR0FBRyxFQUFFLEVBQUVDLGNBQWMsR0FBRyxFQUFFLEVBQUVDLHFCQUFxQixHQUFHLEVBQUUsRUFBRUMsT0FBTyxHQUFHLEVBQUUsRUFBRTtBQUFBLElBQUEsSUFBQUMsZ0JBQUEsQ0FBQTtJQUFBLElBZi9HQyxDQUFBQSxPQUFPLEdBQUcsS0FBSyxDQUFBO0FBZ0JYLElBQUEsSUFBSSxDQUFDekIsRUFBRSxHQUFHQSxFQUFFLEVBQUUsQ0FBQTtJQUNkMEIsV0FBVyxDQUFDQyxPQUFPLENBQUMsSUFBSSxFQUFHLG1CQUFrQixJQUFJLENBQUMzQixFQUFHLENBQUEsQ0FBQyxDQUFDLENBQUE7SUFFdkQsSUFBSSxDQUFDeUIsT0FBTyxHQUFBLENBQUFELGdCQUFBLEdBQUdELE9BQU8sQ0FBQ0UsT0FBTyxLQUFBLElBQUEsR0FBQUQsZ0JBQUEsR0FBSSxLQUFLLENBQUE7QUFDdkNJLElBQUFBLEtBQUssQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQ0osT0FBTyxJQUFJSCxxQkFBcUIsQ0FBQ1EsTUFBTSxLQUFLLENBQUMsRUFBRSxvREFBb0QsQ0FBQyxDQUFBOztBQUV0SDtJQUNBLElBQUksQ0FBQ0MsTUFBTSxHQUFHWixjQUFjLENBQUE7QUFDNUIsSUFBQSxNQUFNYSxLQUFLLEdBQUdiLGNBQWMsQ0FBQ2EsS0FBSyxDQUFBOztBQUVsQztJQUNBLElBQUksQ0FBQ1osYUFBYSxHQUFHQSxhQUFhLENBQUE7O0FBRWxDO0FBQ0E7QUFDQSxJQUFBLElBQUksQ0FBQ2EsZ0JBQWdCLEdBQUcsSUFBSUMsR0FBRyxFQUFFLENBQUE7SUFDakNkLGFBQWEsQ0FBQ2UsT0FBTyxDQUFDLENBQUNDLEVBQUUsRUFBRUMsQ0FBQyxLQUFLLElBQUksQ0FBQ0osZ0JBQWdCLENBQUNLLEdBQUcsQ0FBQ0YsRUFBRSxDQUFDNUIsSUFBSSxFQUFFNkIsQ0FBQyxDQUFDLENBQUMsQ0FBQTs7QUFFdkU7SUFDQSxJQUFJLENBQUNoQixjQUFjLEdBQUdBLGNBQWMsQ0FBQTs7QUFFcEM7QUFDQTtBQUNBLElBQUEsSUFBSSxDQUFDa0IsaUJBQWlCLEdBQUcsSUFBSUwsR0FBRyxFQUFFLENBQUE7QUFDbENiLElBQUFBLGNBQWMsQ0FBQ2MsT0FBTyxDQUFDLENBQUNLLEVBQUUsRUFBRUgsQ0FBQyxLQUFLO01BQzlCLElBQUksQ0FBQ0UsaUJBQWlCLENBQUNELEdBQUcsQ0FBQ0UsRUFBRSxDQUFDaEMsSUFBSSxFQUFFNkIsQ0FBQyxDQUFDLENBQUE7O0FBRXRDO01BQ0FHLEVBQUUsQ0FBQzFCLE9BQU8sR0FBR2tCLEtBQUssQ0FBQ1MsT0FBTyxDQUFDRCxFQUFFLENBQUNoQyxJQUFJLENBQUMsQ0FBQTtBQUN2QyxLQUFDLENBQUMsQ0FBQTs7QUFFRjtJQUNBLElBQUksQ0FBQ2MscUJBQXFCLEdBQUdBLHFCQUFxQixDQUFBOztBQUVsRDtBQUNBO0FBQ0EsSUFBQSxJQUFJLENBQUNvQix3QkFBd0IsR0FBRyxJQUFJUixHQUFHLEVBQUUsQ0FBQTtBQUN6Q1osSUFBQUEscUJBQXFCLENBQUNhLE9BQU8sQ0FBQyxDQUFDSyxFQUFFLEVBQUVILENBQUMsS0FBSztNQUNyQyxJQUFJLENBQUNLLHdCQUF3QixDQUFDSixHQUFHLENBQUNFLEVBQUUsQ0FBQ2hDLElBQUksRUFBRTZCLENBQUMsQ0FBQyxDQUFBOztBQUU3QztNQUNBRyxFQUFFLENBQUMxQixPQUFPLEdBQUdrQixLQUFLLENBQUNTLE9BQU8sQ0FBQ0QsRUFBRSxDQUFDaEMsSUFBSSxDQUFDLENBQUE7QUFDdkMsS0FBQyxDQUFDLENBQUE7SUFFRixJQUFJLENBQUNtQyxJQUFJLEdBQUd4QixjQUFjLENBQUN5Qix5QkFBeUIsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUUxRGhCLElBQUFBLEtBQUssQ0FBQ2lCLEtBQUssQ0FBQ0MsNkJBQTZCLEVBQUcsQ0FBQSxVQUFBLEVBQVksSUFBSSxDQUFDOUMsRUFBRyxDQUFBLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUM1RSxHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNJK0MsRUFBQUEsT0FBT0EsR0FBRztBQUNOLElBQUEsSUFBSSxDQUFDSixJQUFJLENBQUNJLE9BQU8sRUFBRSxDQUFBO0FBQ3ZCLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFVBQVVBLENBQUN4QyxJQUFJLEVBQUU7SUFDYixNQUFNeUMsS0FBSyxHQUFHLElBQUksQ0FBQ1YsaUJBQWlCLENBQUNXLEdBQUcsQ0FBQzFDLElBQUksQ0FBQyxDQUFBO0lBQzlDLElBQUl5QyxLQUFLLEtBQUtFLFNBQVMsRUFBRTtBQUNyQixNQUFBLE9BQU8sSUFBSSxDQUFDOUIsY0FBYyxDQUFDNEIsS0FBSyxDQUFDLENBQUE7QUFDckMsS0FBQTtBQUVBLElBQUEsT0FBTyxJQUFJLENBQUE7QUFDZixHQUFBOztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJRyxpQkFBaUJBLENBQUM1QyxJQUFJLEVBQUU7SUFDcEIsTUFBTXlDLEtBQUssR0FBRyxJQUFJLENBQUNQLHdCQUF3QixDQUFDUSxHQUFHLENBQUMxQyxJQUFJLENBQUMsQ0FBQTtJQUNyRCxJQUFJeUMsS0FBSyxLQUFLRSxTQUFTLEVBQUU7QUFDckIsTUFBQSxPQUFPLElBQUksQ0FBQzdCLHFCQUFxQixDQUFDMkIsS0FBSyxDQUFDLENBQUE7QUFDNUMsS0FBQTtBQUVBLElBQUEsT0FBTyxJQUFJLENBQUE7QUFDZixHQUFBO0VBRUFJLDRCQUE0QkEsQ0FBQ0MsU0FBUyxFQUFFO0lBQ3BDLElBQUlDLElBQUksR0FBRyxFQUFFLENBQUE7QUFDYixJQUFBLElBQUlDLFNBQVMsR0FBRyxJQUFJLENBQUNwQyxhQUFhLENBQUNVLE1BQU0sQ0FBQTtBQUN6QyxJQUFBLElBQUksQ0FBQ1QsY0FBYyxDQUFDYyxPQUFPLENBQUVuQixNQUFNLElBQUs7QUFFcEMsTUFBQSxJQUFJeUMsV0FBVyxHQUFHeEQsb0JBQW9CLENBQUNlLE1BQU0sQ0FBQ0wsZ0JBQWdCLENBQUMsQ0FBQTtNQUMvRGlCLEtBQUssQ0FBQ0MsTUFBTSxDQUFDNEIsV0FBVyxFQUFFLDBCQUEwQixFQUFFekMsTUFBTSxDQUFDTCxnQkFBZ0IsQ0FBQyxDQUFBOztBQUU5RTtNQUNBLElBQUkrQyxXQUFXLEdBQUcsRUFBRSxDQUFBO01BQ3BCLElBQUlDLFNBQVMsR0FBRyxFQUFFLENBQUE7TUFDbEIsSUFBSUYsV0FBVyxLQUFLLGdCQUFnQixFQUFFO0FBQ2xDQyxRQUFBQSxXQUFXLEdBQUcsVUFBVSxDQUFBO0FBQ3hCQyxRQUFBQSxTQUFTLEdBQUksQ0FBQSxRQUFBLEVBQVUzQyxNQUFNLENBQUNSLElBQUssQ0FBa0JRLGdCQUFBQSxFQUFBQSxNQUFNLENBQUNSLElBQUssR0FBRWtELFdBQVksQ0FBQSxFQUFBLEVBQUkxQyxNQUFNLENBQUNSLElBQUssQ0FBWSxXQUFBLENBQUEsQ0FBQTtBQUMvRyxPQUFBO0FBRUEsTUFBQSxJQUFJUSxNQUFNLENBQUNKLFVBQVUsS0FBS2dELGNBQWMsRUFBRTtRQUN0Q0gsV0FBVyxHQUFJLENBQUdBLENBQUFBLEVBQUFBLFdBQVksQ0FBQyxDQUFBLENBQUE7QUFDbkMsT0FBQyxNQUFNLElBQUl6QyxNQUFNLENBQUNKLFVBQVUsS0FBS2lELGVBQWUsRUFBRTtRQUM5Q0osV0FBVyxHQUFJLENBQUdBLENBQUFBLEVBQUFBLFdBQVksQ0FBQyxDQUFBLENBQUE7QUFDbkMsT0FBQTtNQUVBRixJQUFJLElBQUssQ0FBZUQsYUFBQUEsRUFBQUEsU0FBVSxDQUFjRSxZQUFBQSxFQUFBQSxTQUFTLEVBQUcsQ0FBQSxVQUFBLEVBQVlDLFdBQVksQ0FBQSxDQUFBLEVBQUd6QyxNQUFNLENBQUNSLElBQUssQ0FBQSxFQUFFa0QsV0FBWSxDQUFBLEdBQUEsQ0FBSSxHQUM1RyxDQUFBLGFBQUEsRUFBZUosU0FBVSxDQUFBLFlBQUEsRUFBY0UsU0FBUyxFQUFHLENBQW9CeEMsa0JBQUFBLEVBQUFBLE1BQU0sQ0FBQ1IsSUFBSyxDQUFZLFdBQUEsQ0FBQSxHQUNoR21ELFNBQVMsQ0FBQTtBQUVyQixLQUFDLENBQUMsQ0FBQTtBQUVGLElBQUEsT0FBT0osSUFBSSxDQUFBO0FBQ2YsR0FBQTtBQUVBTyxFQUFBQSxXQUFXQSxHQUFHO0FBQ1Y7QUFBQSxHQUFBO0FBRVI7Ozs7In0=
