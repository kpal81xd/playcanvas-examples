import { Shader } from '../shader.js';
import { SHADERLANGUAGE_WGSL } from '../constants.js';
import { Debug, DebugHelper } from '../../../core/debug.js';
import { DebugGraphics } from '../debug-graphics.js';

/**
 * A WebGPU helper class implementing texture mipmap generation.
 *
 * @ignore
 */
class WebgpuMipmapRenderer {
  constructor(device) {
    /** @type {import('./webgpu-graphics-device.js').WebgpuGraphicsDevice} */
    this.device = void 0;
    this.device = device;

    // Shader that renders a fullscreen textured quad
    const code = `
 
            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
                vec2(-1.0, 1.0), vec2(1.0, 1.0),
                vec2(-1.0, -1.0), vec2(1.0, -1.0)
            );

            struct VertexOutput {
                @builtin(position) position : vec4f,
                @location(0) texCoord : vec2f
            };

            @vertex
            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
              var output : VertexOutput;
              output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
              output.position = vec4f(pos[vertexIndex], 0, 1);
              return output;
            }

            @group(0) @binding(0) var imgSampler : sampler;
            @group(0) @binding(1) var img : texture_2d<f32>;

            @fragment
            fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
              return textureSample(img, imgSampler, texCoord);
            }
        `;
    this.shader = new Shader(device, {
      name: 'WebGPUMipmapRendererShader',
      shaderLanguage: SHADERLANGUAGE_WGSL,
      vshader: code,
      fshader: code
    });

    // using minified rendering, so that's the only filter mode we need to set.
    this.minSampler = device.wgpu.createSampler({
      minFilter: 'linear'
    });
  }
  destroy() {
    this.shader.destroy();
    this.shader = null;
  }

  /**
   * Generates mipmaps for the specified WebGPU texture.
   *
   * @param {import('./webgpu-texture.js').WebgpuTexture} webgpuTexture - The texture to generate mipmaps for.
   */
  generate(webgpuTexture) {
    var _device$commandEncode;
    // ignore texture with no mipmaps
    const textureDescr = webgpuTexture.descr;
    if (textureDescr.mipLevelCount <= 1) {
      return;
    }

    // not all types are currently supported
    if (webgpuTexture.texture.volume) {
      Debug.warnOnce('WebGPU mipmap generation is not supported volume texture.', webgpuTexture.texture);
      return;
    }
    const device = this.device;
    const wgpu = device.wgpu;

    /** @type {import('./webgpu-shader.js').WebgpuShader} */
    const webgpuShader = this.shader.impl;
    const pipeline = wgpu.createRenderPipeline({
      layout: 'auto',
      vertex: {
        module: webgpuShader.getVertexShaderModule(),
        entryPoint: webgpuShader.vertexEntryPoint
      },
      fragment: {
        module: webgpuShader.getFragmentShaderModule(),
        entryPoint: webgpuShader.fragmentEntryPoint,
        targets: [{
          format: textureDescr.format // use the same format as the texture
        }]
      },

      primitive: {
        topology: 'triangle-strip'
      }
    });
    DebugHelper.setLabel(pipeline, 'RenderPipeline-MipmapRenderer');
    const texture = webgpuTexture.texture;
    const numFaces = texture.cubemap ? 6 : texture.array ? texture.arrayLength : 1;
    const srcViews = [];
    for (let face = 0; face < numFaces; face++) {
      srcViews.push(webgpuTexture.createView({
        dimension: '2d',
        baseMipLevel: 0,
        mipLevelCount: 1,
        baseArrayLayer: face
      }));
    }

    // loop through each mip level and render the previous level's contents into it.
    const commandEncoder = (_device$commandEncode = device.commandEncoder) != null ? _device$commandEncode : wgpu.createCommandEncoder();
    DebugHelper.setLabel(commandEncoder, 'MipmapRendererEncoder');
    DebugGraphics.pushGpuMarker(device, 'MIPMAP-RENDERER');
    for (let i = 1; i < textureDescr.mipLevelCount; i++) {
      for (let face = 0; face < numFaces; face++) {
        const dstView = webgpuTexture.createView({
          dimension: '2d',
          baseMipLevel: i,
          mipLevelCount: 1,
          baseArrayLayer: face
        });
        const passEncoder = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: dstView,
            loadOp: 'clear',
            storeOp: 'store'
          }]
        });
        DebugHelper.setLabel(passEncoder, `MipmapRenderer-PassEncoder_${i}`);
        const bindGroup = wgpu.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [{
            binding: 0,
            resource: this.minSampler
          }, {
            binding: 1,
            resource: srcViews[face]
          }]
        });
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.draw(4);
        passEncoder.end();

        // next iteration
        srcViews[face] = dstView;
      }
    }
    DebugGraphics.popGpuMarker(device);

    // submit the encoded commands if we created the encoder
    if (!device.commandEncoder) {
      const cb = commandEncoder.finish();
      DebugHelper.setLabel(cb, 'MipmapRenderer-CommandBuffer');
      device.addCommandBuffer(cb);
    }

    // clear invalidated state
    device.pipeline = null;
  }
}

export { WebgpuMipmapRenderer };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ3B1LW1pcG1hcC1yZW5kZXJlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL3BsYXRmb3JtL2dyYXBoaWNzL3dlYmdwdS93ZWJncHUtbWlwbWFwLXJlbmRlcmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlciB9IGZyb20gXCIuLi9zaGFkZXIuanNcIjtcbmltcG9ydCB7IFNIQURFUkxBTkdVQUdFX1dHU0wgfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBEZWJ1ZywgRGVidWdIZWxwZXIgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9kZWJ1Zy5qc1wiO1xuaW1wb3J0IHsgRGVidWdHcmFwaGljcyB9IGZyb20gXCIuLi9kZWJ1Zy1ncmFwaGljcy5qc1wiO1xuXG4vKipcbiAqIEEgV2ViR1BVIGhlbHBlciBjbGFzcyBpbXBsZW1lbnRpbmcgdGV4dHVyZSBtaXBtYXAgZ2VuZXJhdGlvbi5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIFdlYmdwdU1pcG1hcFJlbmRlcmVyIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi93ZWJncHUtZ3JhcGhpY3MtZGV2aWNlLmpzJykuV2ViZ3B1R3JhcGhpY3NEZXZpY2V9ICovXG4gICAgZGV2aWNlO1xuXG4gICAgY29uc3RydWN0b3IoZGV2aWNlKSB7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gZGV2aWNlO1xuXG4gICAgICAgIC8vIFNoYWRlciB0aGF0IHJlbmRlcnMgYSBmdWxsc2NyZWVuIHRleHR1cmVkIHF1YWRcbiAgICAgICAgY29uc3QgY29kZSA9IGBcbiBcbiAgICAgICAgICAgIHZhcjxwcml2YXRlPiBwb3MgOiBhcnJheTx2ZWMyZiwgND4gPSBhcnJheTx2ZWMyZiwgND4oXG4gICAgICAgICAgICAgICAgdmVjMigtMS4wLCAxLjApLCB2ZWMyKDEuMCwgMS4wKSxcbiAgICAgICAgICAgICAgICB2ZWMyKC0xLjAsIC0xLjApLCB2ZWMyKDEuMCwgLTEuMClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHN0cnVjdCBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICAgICAgICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbiA6IHZlYzRmLFxuICAgICAgICAgICAgICAgIEBsb2NhdGlvbigwKSB0ZXhDb29yZCA6IHZlYzJmXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBAdmVydGV4XG4gICAgICAgICAgICBmbiB2ZXJ0ZXhNYWluKEBidWlsdGluKHZlcnRleF9pbmRleCkgdmVydGV4SW5kZXggOiB1MzIpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgICAgICAgIHZhciBvdXRwdXQgOiBWZXJ0ZXhPdXRwdXQ7XG4gICAgICAgICAgICAgIG91dHB1dC50ZXhDb29yZCA9IHBvc1t2ZXJ0ZXhJbmRleF0gKiB2ZWMyZigwLjUsIC0wLjUpICsgdmVjMmYoMC41KTtcbiAgICAgICAgICAgICAgb3V0cHV0LnBvc2l0aW9uID0gdmVjNGYocG9zW3ZlcnRleEluZGV4XSwgMCwgMSk7XG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXIgaW1nU2FtcGxlciA6IHNhbXBsZXI7XG4gICAgICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIGltZyA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgICAgICAgICAgQGZyYWdtZW50XG4gICAgICAgICAgICBmbiBmcmFnbWVudE1haW4oQGxvY2F0aW9uKDApIHRleENvb3JkIDogdmVjMmYpIC0+IEBsb2NhdGlvbigwKSB2ZWM0ZiB7XG4gICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlU2FtcGxlKGltZywgaW1nU2FtcGxlciwgdGV4Q29vcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbmV3IFNoYWRlcihkZXZpY2UsIHtcbiAgICAgICAgICAgIG5hbWU6ICdXZWJHUFVNaXBtYXBSZW5kZXJlclNoYWRlcicsXG4gICAgICAgICAgICBzaGFkZXJMYW5ndWFnZTogU0hBREVSTEFOR1VBR0VfV0dTTCxcbiAgICAgICAgICAgIHZzaGFkZXI6IGNvZGUsXG4gICAgICAgICAgICBmc2hhZGVyOiBjb2RlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHVzaW5nIG1pbmlmaWVkIHJlbmRlcmluZywgc28gdGhhdCdzIHRoZSBvbmx5IGZpbHRlciBtb2RlIHdlIG5lZWQgdG8gc2V0LlxuICAgICAgICB0aGlzLm1pblNhbXBsZXIgPSBkZXZpY2Uud2dwdS5jcmVhdGVTYW1wbGVyKHsgbWluRmlsdGVyOiAnbGluZWFyJyB9KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgbWlwbWFwcyBmb3IgdGhlIHNwZWNpZmllZCBXZWJHUFUgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYmdwdS10ZXh0dXJlLmpzJykuV2ViZ3B1VGV4dHVyZX0gd2ViZ3B1VGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIGdlbmVyYXRlIG1pcG1hcHMgZm9yLlxuICAgICAqL1xuICAgIGdlbmVyYXRlKHdlYmdwdVRleHR1cmUpIHtcblxuICAgICAgICAvLyBpZ25vcmUgdGV4dHVyZSB3aXRoIG5vIG1pcG1hcHNcbiAgICAgICAgY29uc3QgdGV4dHVyZURlc2NyID0gd2ViZ3B1VGV4dHVyZS5kZXNjcjtcbiAgICAgICAgaWYgKHRleHR1cmVEZXNjci5taXBMZXZlbENvdW50IDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdCBhbGwgdHlwZXMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKHdlYmdwdVRleHR1cmUudGV4dHVyZS52b2x1bWUpIHtcbiAgICAgICAgICAgIERlYnVnLndhcm5PbmNlKCdXZWJHUFUgbWlwbWFwIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCB2b2x1bWUgdGV4dHVyZS4nLCB3ZWJncHVUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5kZXZpY2U7XG4gICAgICAgIGNvbnN0IHdncHUgPSBkZXZpY2Uud2dwdTtcblxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi93ZWJncHUtc2hhZGVyLmpzJykuV2ViZ3B1U2hhZGVyfSAqL1xuICAgICAgICBjb25zdCB3ZWJncHVTaGFkZXIgPSB0aGlzLnNoYWRlci5pbXBsO1xuXG4gICAgICAgIGNvbnN0IHBpcGVsaW5lID0gd2dwdS5jcmVhdGVSZW5kZXJQaXBlbGluZSh7XG4gICAgICAgICAgICBsYXlvdXQ6ICdhdXRvJyxcbiAgICAgICAgICAgIHZlcnRleDoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogd2ViZ3B1U2hhZGVyLmdldFZlcnRleFNoYWRlck1vZHVsZSgpLFxuICAgICAgICAgICAgICAgIGVudHJ5UG9pbnQ6IHdlYmdwdVNoYWRlci52ZXJ0ZXhFbnRyeVBvaW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6IHdlYmdwdVNoYWRlci5nZXRGcmFnbWVudFNoYWRlck1vZHVsZSgpLFxuICAgICAgICAgICAgICAgIGVudHJ5UG9pbnQ6IHdlYmdwdVNoYWRlci5mcmFnbWVudEVudHJ5UG9pbnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0czogW3tcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0ZXh0dXJlRGVzY3IuZm9ybWF0IC8vIHVzZSB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIHRleHR1cmVcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaW1pdGl2ZToge1xuICAgICAgICAgICAgICAgIHRvcG9sb2d5OiAndHJpYW5nbGUtc3RyaXAnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBEZWJ1Z0hlbHBlci5zZXRMYWJlbChwaXBlbGluZSwgJ1JlbmRlclBpcGVsaW5lLU1pcG1hcFJlbmRlcmVyJyk7XG5cbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHdlYmdwdVRleHR1cmUudGV4dHVyZTtcbiAgICAgICAgY29uc3QgbnVtRmFjZXMgPSB0ZXh0dXJlLmN1YmVtYXAgPyA2IDogKHRleHR1cmUuYXJyYXkgPyB0ZXh0dXJlLmFycmF5TGVuZ3RoIDogMSk7XG5cbiAgICAgICAgY29uc3Qgc3JjVmlld3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCBudW1GYWNlczsgZmFjZSsrKSB7XG4gICAgICAgICAgICBzcmNWaWV3cy5wdXNoKHdlYmdwdVRleHR1cmUuY3JlYXRlVmlldyh7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uOiAnMmQnLFxuICAgICAgICAgICAgICAgIGJhc2VNaXBMZXZlbDogMCxcbiAgICAgICAgICAgICAgICBtaXBMZXZlbENvdW50OiAxLFxuICAgICAgICAgICAgICAgIGJhc2VBcnJheUxheWVyOiBmYWNlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBtaXAgbGV2ZWwgYW5kIHJlbmRlciB0aGUgcHJldmlvdXMgbGV2ZWwncyBjb250ZW50cyBpbnRvIGl0LlxuICAgICAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IGRldmljZS5jb21tYW5kRW5jb2RlciA/PyB3Z3B1LmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgICAgIERlYnVnSGVscGVyLnNldExhYmVsKGNvbW1hbmRFbmNvZGVyLCAnTWlwbWFwUmVuZGVyZXJFbmNvZGVyJyk7XG5cbiAgICAgICAgRGVidWdHcmFwaGljcy5wdXNoR3B1TWFya2VyKGRldmljZSwgJ01JUE1BUC1SRU5ERVJFUicpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGV4dHVyZURlc2NyLm1pcExldmVsQ291bnQ7IGkrKykge1xuXG4gICAgICAgICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IG51bUZhY2VzOyBmYWNlKyspIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRzdFZpZXcgPSB3ZWJncHVUZXh0dXJlLmNyZWF0ZVZpZXcoe1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb246ICcyZCcsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VNaXBMZXZlbDogaSxcbiAgICAgICAgICAgICAgICAgICAgbWlwTGV2ZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUFycmF5TGF5ZXI6IGZhY2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhc3NFbmNvZGVyID0gY29tbWFuZEVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGRzdFZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkT3A6ICdjbGVhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZU9wOiAnc3RvcmUnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgRGVidWdIZWxwZXIuc2V0TGFiZWwocGFzc0VuY29kZXIsIGBNaXBtYXBSZW5kZXJlci1QYXNzRW5jb2Rlcl8ke2l9YCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiaW5kR3JvdXAgPSB3Z3B1LmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dDogcGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLFxuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiB0aGlzLm1pblNhbXBsZXJcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBzcmNWaWV3c1tmYWNlXVxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcGFzc0VuY29kZXIuc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xuICAgICAgICAgICAgICAgIHBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCBiaW5kR3JvdXApO1xuICAgICAgICAgICAgICAgIHBhc3NFbmNvZGVyLmRyYXcoNCk7XG4gICAgICAgICAgICAgICAgcGFzc0VuY29kZXIuZW5kKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIHNyY1ZpZXdzW2ZhY2VdID0gZHN0VmlldztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIERlYnVnR3JhcGhpY3MucG9wR3B1TWFya2VyKGRldmljZSk7XG5cbiAgICAgICAgLy8gc3VibWl0IHRoZSBlbmNvZGVkIGNvbW1hbmRzIGlmIHdlIGNyZWF0ZWQgdGhlIGVuY29kZXJcbiAgICAgICAgaWYgKCFkZXZpY2UuY29tbWFuZEVuY29kZXIpIHtcblxuICAgICAgICAgICAgY29uc3QgY2IgPSBjb21tYW5kRW5jb2Rlci5maW5pc2goKTtcbiAgICAgICAgICAgIERlYnVnSGVscGVyLnNldExhYmVsKGNiLCAnTWlwbWFwUmVuZGVyZXItQ29tbWFuZEJ1ZmZlcicpO1xuICAgICAgICAgICAgZGV2aWNlLmFkZENvbW1hbmRCdWZmZXIoY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgaW52YWxpZGF0ZWQgc3RhdGVcbiAgICAgICAgZGV2aWNlLnBpcGVsaW5lID0gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFdlYmdwdU1pcG1hcFJlbmRlcmVyIH07XG4iXSwibmFtZXMiOlsiV2ViZ3B1TWlwbWFwUmVuZGVyZXIiLCJjb25zdHJ1Y3RvciIsImRldmljZSIsImNvZGUiLCJzaGFkZXIiLCJTaGFkZXIiLCJuYW1lIiwic2hhZGVyTGFuZ3VhZ2UiLCJTSEFERVJMQU5HVUFHRV9XR1NMIiwidnNoYWRlciIsImZzaGFkZXIiLCJtaW5TYW1wbGVyIiwid2dwdSIsImNyZWF0ZVNhbXBsZXIiLCJtaW5GaWx0ZXIiLCJkZXN0cm95IiwiZ2VuZXJhdGUiLCJ3ZWJncHVUZXh0dXJlIiwiX2RldmljZSRjb21tYW5kRW5jb2RlIiwidGV4dHVyZURlc2NyIiwiZGVzY3IiLCJtaXBMZXZlbENvdW50IiwidGV4dHVyZSIsInZvbHVtZSIsIkRlYnVnIiwid2Fybk9uY2UiLCJ3ZWJncHVTaGFkZXIiLCJpbXBsIiwicGlwZWxpbmUiLCJjcmVhdGVSZW5kZXJQaXBlbGluZSIsImxheW91dCIsInZlcnRleCIsIm1vZHVsZSIsImdldFZlcnRleFNoYWRlck1vZHVsZSIsImVudHJ5UG9pbnQiLCJ2ZXJ0ZXhFbnRyeVBvaW50IiwiZnJhZ21lbnQiLCJnZXRGcmFnbWVudFNoYWRlck1vZHVsZSIsImZyYWdtZW50RW50cnlQb2ludCIsInRhcmdldHMiLCJmb3JtYXQiLCJwcmltaXRpdmUiLCJ0b3BvbG9neSIsIkRlYnVnSGVscGVyIiwic2V0TGFiZWwiLCJudW1GYWNlcyIsImN1YmVtYXAiLCJhcnJheSIsImFycmF5TGVuZ3RoIiwic3JjVmlld3MiLCJmYWNlIiwicHVzaCIsImNyZWF0ZVZpZXciLCJkaW1lbnNpb24iLCJiYXNlTWlwTGV2ZWwiLCJiYXNlQXJyYXlMYXllciIsImNvbW1hbmRFbmNvZGVyIiwiY3JlYXRlQ29tbWFuZEVuY29kZXIiLCJEZWJ1Z0dyYXBoaWNzIiwicHVzaEdwdU1hcmtlciIsImkiLCJkc3RWaWV3IiwicGFzc0VuY29kZXIiLCJiZWdpblJlbmRlclBhc3MiLCJjb2xvckF0dGFjaG1lbnRzIiwidmlldyIsImxvYWRPcCIsInN0b3JlT3AiLCJiaW5kR3JvdXAiLCJjcmVhdGVCaW5kR3JvdXAiLCJnZXRCaW5kR3JvdXBMYXlvdXQiLCJlbnRyaWVzIiwiYmluZGluZyIsInJlc291cmNlIiwic2V0UGlwZWxpbmUiLCJzZXRCaW5kR3JvdXAiLCJkcmF3IiwiZW5kIiwicG9wR3B1TWFya2VyIiwiY2IiLCJmaW5pc2giLCJhZGRDb21tYW5kQnVmZmVyIl0sIm1hcHBpbmdzIjoiOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxvQkFBb0IsQ0FBQztFQUl2QkMsV0FBV0EsQ0FBQ0MsTUFBTSxFQUFFO0FBSHBCO0FBQUEsSUFBQSxJQUFBLENBQ0FBLE1BQU0sR0FBQSxLQUFBLENBQUEsQ0FBQTtJQUdGLElBQUksQ0FBQ0EsTUFBTSxHQUFHQSxNQUFNLENBQUE7O0FBRXBCO0FBQ0EsSUFBQSxNQUFNQyxJQUFJLEdBQUksQ0FBQTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUyxDQUFBLENBQUE7QUFFRCxJQUFBLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUlDLE1BQU0sQ0FBQ0gsTUFBTSxFQUFFO0FBQzdCSSxNQUFBQSxJQUFJLEVBQUUsNEJBQTRCO0FBQ2xDQyxNQUFBQSxjQUFjLEVBQUVDLG1CQUFtQjtBQUNuQ0MsTUFBQUEsT0FBTyxFQUFFTixJQUFJO0FBQ2JPLE1BQUFBLE9BQU8sRUFBRVAsSUFBQUE7QUFDYixLQUFDLENBQUMsQ0FBQTs7QUFFRjtJQUNBLElBQUksQ0FBQ1EsVUFBVSxHQUFHVCxNQUFNLENBQUNVLElBQUksQ0FBQ0MsYUFBYSxDQUFDO0FBQUVDLE1BQUFBLFNBQVMsRUFBRSxRQUFBO0FBQVMsS0FBQyxDQUFDLENBQUE7QUFDeEUsR0FBQTtBQUVBQyxFQUFBQSxPQUFPQSxHQUFHO0FBQ04sSUFBQSxJQUFJLENBQUNYLE1BQU0sQ0FBQ1csT0FBTyxFQUFFLENBQUE7SUFDckIsSUFBSSxDQUFDWCxNQUFNLEdBQUcsSUFBSSxDQUFBO0FBQ3RCLEdBQUE7O0FBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtFQUNJWSxRQUFRQSxDQUFDQyxhQUFhLEVBQUU7QUFBQSxJQUFBLElBQUFDLHFCQUFBLENBQUE7QUFFcEI7QUFDQSxJQUFBLE1BQU1DLFlBQVksR0FBR0YsYUFBYSxDQUFDRyxLQUFLLENBQUE7QUFDeEMsSUFBQSxJQUFJRCxZQUFZLENBQUNFLGFBQWEsSUFBSSxDQUFDLEVBQUU7QUFDakMsTUFBQSxPQUFBO0FBQ0osS0FBQTs7QUFFQTtBQUNBLElBQUEsSUFBSUosYUFBYSxDQUFDSyxPQUFPLENBQUNDLE1BQU0sRUFBRTtNQUM5QkMsS0FBSyxDQUFDQyxRQUFRLENBQUMsMkRBQTJELEVBQUVSLGFBQWEsQ0FBQ0ssT0FBTyxDQUFDLENBQUE7QUFDbEcsTUFBQSxPQUFBO0FBQ0osS0FBQTtBQUVBLElBQUEsTUFBTXBCLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQTtBQUMxQixJQUFBLE1BQU1VLElBQUksR0FBR1YsTUFBTSxDQUFDVSxJQUFJLENBQUE7O0FBRXhCO0FBQ0EsSUFBQSxNQUFNYyxZQUFZLEdBQUcsSUFBSSxDQUFDdEIsTUFBTSxDQUFDdUIsSUFBSSxDQUFBO0FBRXJDLElBQUEsTUFBTUMsUUFBUSxHQUFHaEIsSUFBSSxDQUFDaUIsb0JBQW9CLENBQUM7QUFDdkNDLE1BQUFBLE1BQU0sRUFBRSxNQUFNO0FBQ2RDLE1BQUFBLE1BQU0sRUFBRTtBQUNKQyxRQUFBQSxNQUFNLEVBQUVOLFlBQVksQ0FBQ08scUJBQXFCLEVBQUU7UUFDNUNDLFVBQVUsRUFBRVIsWUFBWSxDQUFDUyxnQkFBQUE7T0FDNUI7QUFDREMsTUFBQUEsUUFBUSxFQUFFO0FBQ05KLFFBQUFBLE1BQU0sRUFBRU4sWUFBWSxDQUFDVyx1QkFBdUIsRUFBRTtRQUM5Q0gsVUFBVSxFQUFFUixZQUFZLENBQUNZLGtCQUFrQjtBQUMzQ0MsUUFBQUEsT0FBTyxFQUFFLENBQUM7QUFDTkMsVUFBQUEsTUFBTSxFQUFFckIsWUFBWSxDQUFDcUIsTUFBTTtTQUM5QixDQUFBO09BQ0o7O0FBQ0RDLE1BQUFBLFNBQVMsRUFBRTtBQUNQQyxRQUFBQSxRQUFRLEVBQUUsZ0JBQUE7QUFDZCxPQUFBO0FBQ0osS0FBQyxDQUFDLENBQUE7QUFDRkMsSUFBQUEsV0FBVyxDQUFDQyxRQUFRLENBQUNoQixRQUFRLEVBQUUsK0JBQStCLENBQUMsQ0FBQTtBQUUvRCxJQUFBLE1BQU1OLE9BQU8sR0FBR0wsYUFBYSxDQUFDSyxPQUFPLENBQUE7QUFDckMsSUFBQSxNQUFNdUIsUUFBUSxHQUFHdkIsT0FBTyxDQUFDd0IsT0FBTyxHQUFHLENBQUMsR0FBSXhCLE9BQU8sQ0FBQ3lCLEtBQUssR0FBR3pCLE9BQU8sQ0FBQzBCLFdBQVcsR0FBRyxDQUFFLENBQUE7SUFFaEYsTUFBTUMsUUFBUSxHQUFHLEVBQUUsQ0FBQTtJQUNuQixLQUFLLElBQUlDLElBQUksR0FBRyxDQUFDLEVBQUVBLElBQUksR0FBR0wsUUFBUSxFQUFFSyxJQUFJLEVBQUUsRUFBRTtBQUN4Q0QsTUFBQUEsUUFBUSxDQUFDRSxJQUFJLENBQUNsQyxhQUFhLENBQUNtQyxVQUFVLENBQUM7QUFDbkNDLFFBQUFBLFNBQVMsRUFBRSxJQUFJO0FBQ2ZDLFFBQUFBLFlBQVksRUFBRSxDQUFDO0FBQ2ZqQyxRQUFBQSxhQUFhLEVBQUUsQ0FBQztBQUNoQmtDLFFBQUFBLGNBQWMsRUFBRUwsSUFBQUE7QUFDcEIsT0FBQyxDQUFDLENBQUMsQ0FBQTtBQUNQLEtBQUE7O0FBRUE7QUFDQSxJQUFBLE1BQU1NLGNBQWMsR0FBQSxDQUFBdEMscUJBQUEsR0FBR2hCLE1BQU0sQ0FBQ3NELGNBQWMsS0FBQXRDLElBQUFBLEdBQUFBLHFCQUFBLEdBQUlOLElBQUksQ0FBQzZDLG9CQUFvQixFQUFFLENBQUE7QUFDM0VkLElBQUFBLFdBQVcsQ0FBQ0MsUUFBUSxDQUFDWSxjQUFjLEVBQUUsdUJBQXVCLENBQUMsQ0FBQTtBQUU3REUsSUFBQUEsYUFBYSxDQUFDQyxhQUFhLENBQUN6RCxNQUFNLEVBQUUsaUJBQWlCLENBQUMsQ0FBQTtBQUV0RCxJQUFBLEtBQUssSUFBSTBELENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3pDLFlBQVksQ0FBQ0UsYUFBYSxFQUFFdUMsQ0FBQyxFQUFFLEVBQUU7TUFFakQsS0FBSyxJQUFJVixJQUFJLEdBQUcsQ0FBQyxFQUFFQSxJQUFJLEdBQUdMLFFBQVEsRUFBRUssSUFBSSxFQUFFLEVBQUU7QUFFeEMsUUFBQSxNQUFNVyxPQUFPLEdBQUc1QyxhQUFhLENBQUNtQyxVQUFVLENBQUM7QUFDckNDLFVBQUFBLFNBQVMsRUFBRSxJQUFJO0FBQ2ZDLFVBQUFBLFlBQVksRUFBRU0sQ0FBQztBQUNmdkMsVUFBQUEsYUFBYSxFQUFFLENBQUM7QUFDaEJrQyxVQUFBQSxjQUFjLEVBQUVMLElBQUFBO0FBQ3BCLFNBQUMsQ0FBQyxDQUFBO0FBRUYsUUFBQSxNQUFNWSxXQUFXLEdBQUdOLGNBQWMsQ0FBQ08sZUFBZSxDQUFDO0FBQy9DQyxVQUFBQSxnQkFBZ0IsRUFBRSxDQUFDO0FBQ2ZDLFlBQUFBLElBQUksRUFBRUosT0FBTztBQUNiSyxZQUFBQSxNQUFNLEVBQUUsT0FBTztBQUNmQyxZQUFBQSxPQUFPLEVBQUUsT0FBQTtXQUNaLENBQUE7QUFDTCxTQUFDLENBQUMsQ0FBQTtRQUNGeEIsV0FBVyxDQUFDQyxRQUFRLENBQUNrQixXQUFXLEVBQUcsQ0FBNkJGLDJCQUFBQSxFQUFBQSxDQUFFLEVBQUMsQ0FBQyxDQUFBO0FBRXBFLFFBQUEsTUFBTVEsU0FBUyxHQUFHeEQsSUFBSSxDQUFDeUQsZUFBZSxDQUFDO0FBQ25DdkMsVUFBQUEsTUFBTSxFQUFFRixRQUFRLENBQUMwQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7QUFDdENDLFVBQUFBLE9BQU8sRUFBRSxDQUFDO0FBQ05DLFlBQUFBLE9BQU8sRUFBRSxDQUFDO1lBQ1ZDLFFBQVEsRUFBRSxJQUFJLENBQUM5RCxVQUFBQTtBQUNuQixXQUFDLEVBQUU7QUFDQzZELFlBQUFBLE9BQU8sRUFBRSxDQUFDO1lBQ1ZDLFFBQVEsRUFBRXhCLFFBQVEsQ0FBQ0MsSUFBSSxDQUFBO1dBQzFCLENBQUE7QUFDTCxTQUFDLENBQUMsQ0FBQTtBQUVGWSxRQUFBQSxXQUFXLENBQUNZLFdBQVcsQ0FBQzlDLFFBQVEsQ0FBQyxDQUFBO0FBQ2pDa0MsUUFBQUEsV0FBVyxDQUFDYSxZQUFZLENBQUMsQ0FBQyxFQUFFUCxTQUFTLENBQUMsQ0FBQTtBQUN0Q04sUUFBQUEsV0FBVyxDQUFDYyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDbkJkLFdBQVcsQ0FBQ2UsR0FBRyxFQUFFLENBQUE7O0FBRWpCO0FBQ0E1QixRQUFBQSxRQUFRLENBQUNDLElBQUksQ0FBQyxHQUFHVyxPQUFPLENBQUE7QUFDNUIsT0FBQTtBQUNKLEtBQUE7QUFFQUgsSUFBQUEsYUFBYSxDQUFDb0IsWUFBWSxDQUFDNUUsTUFBTSxDQUFDLENBQUE7O0FBRWxDO0FBQ0EsSUFBQSxJQUFJLENBQUNBLE1BQU0sQ0FBQ3NELGNBQWMsRUFBRTtBQUV4QixNQUFBLE1BQU11QixFQUFFLEdBQUd2QixjQUFjLENBQUN3QixNQUFNLEVBQUUsQ0FBQTtBQUNsQ3JDLE1BQUFBLFdBQVcsQ0FBQ0MsUUFBUSxDQUFDbUMsRUFBRSxFQUFFLDhCQUE4QixDQUFDLENBQUE7QUFDeEQ3RSxNQUFBQSxNQUFNLENBQUMrRSxnQkFBZ0IsQ0FBQ0YsRUFBRSxDQUFDLENBQUE7QUFDL0IsS0FBQTs7QUFFQTtJQUNBN0UsTUFBTSxDQUFDMEIsUUFBUSxHQUFHLElBQUksQ0FBQTtBQUMxQixHQUFBO0FBQ0o7Ozs7In0=
