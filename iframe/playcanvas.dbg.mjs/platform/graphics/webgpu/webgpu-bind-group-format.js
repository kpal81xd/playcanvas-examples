import { Debug, DebugHelper } from '../../../core/debug.js';
import { StringIds } from '../../../core/string-ids.js';
import { SAMPLETYPE_FLOAT, SAMPLETYPE_UNFILTERABLE_FLOAT, SAMPLETYPE_DEPTH, SAMPLETYPE_INT, SAMPLETYPE_UINT } from '../constants.js';
import { WebgpuUtils } from './webgpu-utils.js';
import { gpuTextureFormats } from './constants.js';

const samplerTypes = [];
samplerTypes[SAMPLETYPE_FLOAT] = 'filtering';
samplerTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = 'non-filtering';
samplerTypes[SAMPLETYPE_DEPTH] = 'comparison';

// Using 'comparison' instead of 'non-filtering' may seem unusual, but currently we will get a
// validation error if we use 'non-filtering' along with texelFetch/textureLoad. 'comparison' works
// very well for the most common use-case of integer textures, texelFetch. We may be able to change
// how we initialize the sampler elsewhere to support 'non-filtering' in the future.
samplerTypes[SAMPLETYPE_INT] = 'comparison';
samplerTypes[SAMPLETYPE_UINT] = 'comparison';
const sampleTypes = [];
sampleTypes[SAMPLETYPE_FLOAT] = 'float';
sampleTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = 'unfilterable-float';
sampleTypes[SAMPLETYPE_DEPTH] = 'depth';
sampleTypes[SAMPLETYPE_INT] = 'sint';
sampleTypes[SAMPLETYPE_UINT] = 'uint';
const stringIds = new StringIds();

/**
 * A WebGPU implementation of the BindGroupFormat, which is a wrapper over GPUBindGroupLayout.
 *
 * @ignore
 */
class WebgpuBindGroupFormat {
  /**
   * @param {import('../bind-group-format.js').BindGroupFormat} bindGroupFormat - Bind group format.
   */
  constructor(bindGroupFormat) {
    /** @type {import('./webgpu-graphics-device.js').WebgpuGraphicsDevice} */
    const device = bindGroupFormat.device;
    const {
      key,
      descr
    } = this.createDescriptor(bindGroupFormat);

    /**
     * Unique key, used for caching
     *
     * @type {number}
     */
    this.key = stringIds.get(key);

    // keep descr in debug mode
    Debug.call(() => {
      this.descr = descr;
    });

    /**
     * @type {GPUBindGroupLayout}
     * @private
     */
    this.bindGroupLayout = device.wgpu.createBindGroupLayout(descr);
    DebugHelper.setLabel(this.bindGroupLayout, bindGroupFormat.name);
  }
  destroy() {
    this.bindGroupLayout = null;
  }
  loseContext() {
    // this.bindGroupLayout = null;
  }

  /**
   * Returns texture binding slot.
   *
   * @param {import('../bind-group-format.js').BindGroupFormat} bindGroupFormat - Bind group format.
   * @param {number} index - The index of the texture.
   * @returns {number} - The slot index.
   */
  getTextureSlot(bindGroupFormat, index) {
    // each texture takes 2 slots (texture, sampler) and those are added after uniform buffers
    return bindGroupFormat.bufferFormats.length + index * 2;
  }

  /**
   * @param {any} bindGroupFormat - The format of the bind group.
   * @returns {any} Returns the bind group descriptor.
   */
  createDescriptor(bindGroupFormat) {
    // all WebGPU bindings:
    // - buffer: GPUBufferBindingLayout, resource type is GPUBufferBinding
    // - sampler: GPUSamplerBindingLayout, resource type is GPUSampler
    // - texture: GPUTextureBindingLayout, resource type is GPUTextureView
    // - storageTexture: GPUStorageTextureBindingLayout, resource type is GPUTextureView
    // - externalTexture: GPUExternalTextureBindingLayout, resource type is GPUExternalTexture
    const entries = [];

    // generate unique key
    let key = '';
    let index = 0;

    // buffers
    bindGroupFormat.bufferFormats.forEach(bufferFormat => {
      const visibility = WebgpuUtils.shaderStage(bufferFormat.visibility);
      key += `#${index}U:${visibility}`;
      entries.push({
        binding: index++,
        visibility: visibility,
        buffer: {
          type: 'uniform',
          // "uniform", "storage", "read-only-storage"

          // whether this binding requires a dynamic offset
          // currently all UBs are dynamic and need the offset
          hasDynamicOffset: true

          // defaults to 0 meaning no validation, can do early size validation using it
          // minBindingSize
        }
      });
    });

    // textures
    bindGroupFormat.textureFormats.forEach(textureFormat => {
      const visibility = WebgpuUtils.shaderStage(textureFormat.visibility);

      // texture
      const sampleType = textureFormat.sampleType;
      const viewDimension = textureFormat.textureDimension;
      const multisampled = false;
      const gpuSampleType = sampleTypes[sampleType];
      Debug.assert(gpuSampleType);
      key += `#${index}T:${visibility}-${gpuSampleType}-${viewDimension}-${multisampled}`;

      // texture
      entries.push({
        binding: index++,
        visibility: visibility,
        texture: {
          // Indicates the type required for texture views bound to this binding.
          // "float", "unfilterable-float", "depth", "sint", "uint",
          sampleType: gpuSampleType,
          // Indicates the required dimension for texture views bound to this binding.
          // "1d", "2d", "2d-array", "cube", "cube-array", "3d"
          viewDimension: viewDimension,
          // Indicates whether or not texture views bound to this binding must be multisampled
          multisampled: multisampled
        }
      });

      // sampler
      const gpuSamplerType = samplerTypes[sampleType];
      Debug.assert(gpuSamplerType);
      key += `#${index}S:${visibility}-${gpuSamplerType}`;
      entries.push({
        binding: index++,
        visibility: visibility,
        sampler: {
          // Indicates the required type of a sampler bound to this bindings
          // 'filtering', 'non-filtering', 'comparison'
          type: gpuSamplerType
        }
      });
    });

    // storage textures
    bindGroupFormat.storageTextureFormats.forEach(textureFormat => {
      const {
        format,
        textureDimension
      } = textureFormat;
      key += `#${index}ST:${format}-${textureDimension}`;

      // storage texture
      entries.push({
        binding: index++,
        visibility: GPUShaderStage.COMPUTE,
        storageTexture: {
          // The access mode for this binding, indicating readability and writability.
          access: 'write-only',
          // only single option currently, more in the future

          // The required format of texture views bound to this binding.
          format: gpuTextureFormats[format],
          // Indicates the required dimension for texture views bound to this binding.
          // "1d", "2d", "2d-array", "cube", "cube-array", "3d"
          viewDimension: textureDimension
        }
      });
    });

    /** @type {GPUBindGroupLayoutDescriptor} */
    const descr = {
      entries: entries
    };
    return {
      key,
      descr
    };
  }
}

export { WebgpuBindGroupFormat };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ3B1LWJpbmQtZ3JvdXAtZm9ybWF0LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvcGxhdGZvcm0vZ3JhcGhpY3Mvd2ViZ3B1L3dlYmdwdS1iaW5kLWdyb3VwLWZvcm1hdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJ1ZywgRGVidWdIZWxwZXIgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IFN0cmluZ0lkcyB9IGZyb20gJy4uLy4uLy4uL2NvcmUvc3RyaW5nLWlkcy5qcyc7XG5pbXBvcnQgeyBTQU1QTEVUWVBFX0ZMT0FULCBTQU1QTEVUWVBFX1VORklMVEVSQUJMRV9GTE9BVCwgU0FNUExFVFlQRV9ERVBUSCwgU0FNUExFVFlQRV9JTlQsIFNBTVBMRVRZUEVfVUlOVCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbmltcG9ydCB7IFdlYmdwdVV0aWxzIH0gZnJvbSAnLi93ZWJncHUtdXRpbHMuanMnO1xuaW1wb3J0IHsgZ3B1VGV4dHVyZUZvcm1hdHMgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IHNhbXBsZXJUeXBlcyA9IFtdO1xuc2FtcGxlclR5cGVzW1NBTVBMRVRZUEVfRkxPQVRdID0gJ2ZpbHRlcmluZyc7XG5zYW1wbGVyVHlwZXNbU0FNUExFVFlQRV9VTkZJTFRFUkFCTEVfRkxPQVRdID0gJ25vbi1maWx0ZXJpbmcnO1xuc2FtcGxlclR5cGVzW1NBTVBMRVRZUEVfREVQVEhdID0gJ2NvbXBhcmlzb24nO1xuXG4vLyBVc2luZyAnY29tcGFyaXNvbicgaW5zdGVhZCBvZiAnbm9uLWZpbHRlcmluZycgbWF5IHNlZW0gdW51c3VhbCwgYnV0IGN1cnJlbnRseSB3ZSB3aWxsIGdldCBhXG4vLyB2YWxpZGF0aW9uIGVycm9yIGlmIHdlIHVzZSAnbm9uLWZpbHRlcmluZycgYWxvbmcgd2l0aCB0ZXhlbEZldGNoL3RleHR1cmVMb2FkLiAnY29tcGFyaXNvbicgd29ya3Ncbi8vIHZlcnkgd2VsbCBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZS1jYXNlIG9mIGludGVnZXIgdGV4dHVyZXMsIHRleGVsRmV0Y2guIFdlIG1heSBiZSBhYmxlIHRvIGNoYW5nZVxuLy8gaG93IHdlIGluaXRpYWxpemUgdGhlIHNhbXBsZXIgZWxzZXdoZXJlIHRvIHN1cHBvcnQgJ25vbi1maWx0ZXJpbmcnIGluIHRoZSBmdXR1cmUuXG5zYW1wbGVyVHlwZXNbU0FNUExFVFlQRV9JTlRdID0gJ2NvbXBhcmlzb24nO1xuc2FtcGxlclR5cGVzW1NBTVBMRVRZUEVfVUlOVF0gPSAnY29tcGFyaXNvbic7XG5cbmNvbnN0IHNhbXBsZVR5cGVzID0gW107XG5zYW1wbGVUeXBlc1tTQU1QTEVUWVBFX0ZMT0FUXSA9ICdmbG9hdCc7XG5zYW1wbGVUeXBlc1tTQU1QTEVUWVBFX1VORklMVEVSQUJMRV9GTE9BVF0gPSAndW5maWx0ZXJhYmxlLWZsb2F0JztcbnNhbXBsZVR5cGVzW1NBTVBMRVRZUEVfREVQVEhdID0gJ2RlcHRoJztcbnNhbXBsZVR5cGVzW1NBTVBMRVRZUEVfSU5UXSA9ICdzaW50JztcbnNhbXBsZVR5cGVzW1NBTVBMRVRZUEVfVUlOVF0gPSAndWludCc7XG5cbmNvbnN0IHN0cmluZ0lkcyA9IG5ldyBTdHJpbmdJZHMoKTtcblxuLyoqXG4gKiBBIFdlYkdQVSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQmluZEdyb3VwRm9ybWF0LCB3aGljaCBpcyBhIHdyYXBwZXIgb3ZlciBHUFVCaW5kR3JvdXBMYXlvdXQuXG4gKlxuICogQGlnbm9yZVxuICovXG5jbGFzcyBXZWJncHVCaW5kR3JvdXBGb3JtYXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9iaW5kLWdyb3VwLWZvcm1hdC5qcycpLkJpbmRHcm91cEZvcm1hdH0gYmluZEdyb3VwRm9ybWF0IC0gQmluZCBncm91cCBmb3JtYXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmluZEdyb3VwRm9ybWF0KSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vd2ViZ3B1LWdyYXBoaWNzLWRldmljZS5qcycpLldlYmdwdUdyYXBoaWNzRGV2aWNlfSAqL1xuICAgICAgICBjb25zdCBkZXZpY2UgPSBiaW5kR3JvdXBGb3JtYXQuZGV2aWNlO1xuXG4gICAgICAgIGNvbnN0IHsga2V5LCBkZXNjciB9ID0gdGhpcy5jcmVhdGVEZXNjcmlwdG9yKGJpbmRHcm91cEZvcm1hdCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuaXF1ZSBrZXksIHVzZWQgZm9yIGNhY2hpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2V5ID0gc3RyaW5nSWRzLmdldChrZXkpO1xuXG4gICAgICAgIC8vIGtlZXAgZGVzY3IgaW4gZGVidWcgbW9kZVxuICAgICAgICBEZWJ1Zy5jYWxsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVzY3IgPSBkZXNjcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtHUFVCaW5kR3JvdXBMYXlvdXR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJpbmRHcm91cExheW91dCA9IGRldmljZS53Z3B1LmNyZWF0ZUJpbmRHcm91cExheW91dChkZXNjcik7XG4gICAgICAgIERlYnVnSGVscGVyLnNldExhYmVsKHRoaXMuYmluZEdyb3VwTGF5b3V0LCBiaW5kR3JvdXBGb3JtYXQubmFtZSk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5iaW5kR3JvdXBMYXlvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIGxvc2VDb250ZXh0KCkge1xuICAgICAgICAvLyB0aGlzLmJpbmRHcm91cExheW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZXh0dXJlIGJpbmRpbmcgc2xvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9iaW5kLWdyb3VwLWZvcm1hdC5qcycpLkJpbmRHcm91cEZvcm1hdH0gYmluZEdyb3VwRm9ybWF0IC0gQmluZCBncm91cCBmb3JtYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIHNsb3QgaW5kZXguXG4gICAgICovXG4gICAgZ2V0VGV4dHVyZVNsb3QoYmluZEdyb3VwRm9ybWF0LCBpbmRleCkge1xuICAgICAgICAvLyBlYWNoIHRleHR1cmUgdGFrZXMgMiBzbG90cyAodGV4dHVyZSwgc2FtcGxlcikgYW5kIHRob3NlIGFyZSBhZGRlZCBhZnRlciB1bmlmb3JtIGJ1ZmZlcnNcbiAgICAgICAgcmV0dXJuIGJpbmRHcm91cEZvcm1hdC5idWZmZXJGb3JtYXRzLmxlbmd0aCArIGluZGV4ICogMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gYmluZEdyb3VwRm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgYmluZCBncm91cC5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBSZXR1cm5zIHRoZSBiaW5kIGdyb3VwIGRlc2NyaXB0b3IuXG4gICAgICovXG4gICAgY3JlYXRlRGVzY3JpcHRvcihiaW5kR3JvdXBGb3JtYXQpIHtcblxuICAgICAgICAvLyBhbGwgV2ViR1BVIGJpbmRpbmdzOlxuICAgICAgICAvLyAtIGJ1ZmZlcjogR1BVQnVmZmVyQmluZGluZ0xheW91dCwgcmVzb3VyY2UgdHlwZSBpcyBHUFVCdWZmZXJCaW5kaW5nXG4gICAgICAgIC8vIC0gc2FtcGxlcjogR1BVU2FtcGxlckJpbmRpbmdMYXlvdXQsIHJlc291cmNlIHR5cGUgaXMgR1BVU2FtcGxlclxuICAgICAgICAvLyAtIHRleHR1cmU6IEdQVVRleHR1cmVCaW5kaW5nTGF5b3V0LCByZXNvdXJjZSB0eXBlIGlzIEdQVVRleHR1cmVWaWV3XG4gICAgICAgIC8vIC0gc3RvcmFnZVRleHR1cmU6IEdQVVN0b3JhZ2VUZXh0dXJlQmluZGluZ0xheW91dCwgcmVzb3VyY2UgdHlwZSBpcyBHUFVUZXh0dXJlVmlld1xuICAgICAgICAvLyAtIGV4dGVybmFsVGV4dHVyZTogR1BVRXh0ZXJuYWxUZXh0dXJlQmluZGluZ0xheW91dCwgcmVzb3VyY2UgdHlwZSBpcyBHUFVFeHRlcm5hbFRleHR1cmVcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIHVuaXF1ZSBrZXlcbiAgICAgICAgbGV0IGtleSA9ICcnO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgICAgIC8vIGJ1ZmZlcnNcbiAgICAgICAgYmluZEdyb3VwRm9ybWF0LmJ1ZmZlckZvcm1hdHMuZm9yRWFjaCgoYnVmZmVyRm9ybWF0KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSBXZWJncHVVdGlscy5zaGFkZXJTdGFnZShidWZmZXJGb3JtYXQudmlzaWJpbGl0eSk7XG4gICAgICAgICAgICBrZXkgKz0gYCMke2luZGV4fVU6JHt2aXNpYmlsaXR5fWA7XG5cbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgYmluZGluZzogaW5kZXgrKyxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5LFxuXG4gICAgICAgICAgICAgICAgYnVmZmVyOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuaWZvcm0nLCAvLyBcInVuaWZvcm1cIiwgXCJzdG9yYWdlXCIsIFwicmVhZC1vbmx5LXN0b3JhZ2VcIlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhpcyBiaW5kaW5nIHJlcXVpcmVzIGEgZHluYW1pYyBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudGx5IGFsbCBVQnMgYXJlIGR5bmFtaWMgYW5kIG5lZWQgdGhlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBoYXNEeW5hbWljT2Zmc2V0OiB0cnVlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gMCBtZWFuaW5nIG5vIHZhbGlkYXRpb24sIGNhbiBkbyBlYXJseSBzaXplIHZhbGlkYXRpb24gdXNpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbWluQmluZGluZ1NpemVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGV4dHVyZXNcbiAgICAgICAgYmluZEdyb3VwRm9ybWF0LnRleHR1cmVGb3JtYXRzLmZvckVhY2goKHRleHR1cmVGb3JtYXQpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IFdlYmdwdVV0aWxzLnNoYWRlclN0YWdlKHRleHR1cmVGb3JtYXQudmlzaWJpbGl0eSk7XG5cbiAgICAgICAgICAgIC8vIHRleHR1cmVcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVR5cGUgPSB0ZXh0dXJlRm9ybWF0LnNhbXBsZVR5cGU7XG4gICAgICAgICAgICBjb25zdCB2aWV3RGltZW5zaW9uID0gdGV4dHVyZUZvcm1hdC50ZXh0dXJlRGltZW5zaW9uO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlzYW1wbGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGdwdVNhbXBsZVR5cGUgPSBzYW1wbGVUeXBlc1tzYW1wbGVUeXBlXTtcbiAgICAgICAgICAgIERlYnVnLmFzc2VydChncHVTYW1wbGVUeXBlKTtcblxuICAgICAgICAgICAga2V5ICs9IGAjJHtpbmRleH1UOiR7dmlzaWJpbGl0eX0tJHtncHVTYW1wbGVUeXBlfS0ke3ZpZXdEaW1lbnNpb259LSR7bXVsdGlzYW1wbGVkfWA7XG5cbiAgICAgICAgICAgIC8vIHRleHR1cmVcbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgYmluZGluZzogaW5kZXgrKyxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5LFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kaWNhdGVzIHRoZSB0eXBlIHJlcXVpcmVkIGZvciB0ZXh0dXJlIHZpZXdzIGJvdW5kIHRvIHRoaXMgYmluZGluZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gXCJmbG9hdFwiLCBcInVuZmlsdGVyYWJsZS1mbG9hdFwiLCBcImRlcHRoXCIsIFwic2ludFwiLCBcInVpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlVHlwZTogZ3B1U2FtcGxlVHlwZSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIGRpbWVuc2lvbiBmb3IgdGV4dHVyZSB2aWV3cyBib3VuZCB0byB0aGlzIGJpbmRpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiMWRcIiwgXCIyZFwiLCBcIjJkLWFycmF5XCIsIFwiY3ViZVwiLCBcImN1YmUtYXJyYXlcIiwgXCIzZFwiXG4gICAgICAgICAgICAgICAgICAgIHZpZXdEaW1lbnNpb246IHZpZXdEaW1lbnNpb24sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRleHR1cmUgdmlld3MgYm91bmQgdG8gdGhpcyBiaW5kaW5nIG11c3QgYmUgbXVsdGlzYW1wbGVkXG4gICAgICAgICAgICAgICAgICAgIG11bHRpc2FtcGxlZDogbXVsdGlzYW1wbGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNhbXBsZXJcbiAgICAgICAgICAgIGNvbnN0IGdwdVNhbXBsZXJUeXBlID0gc2FtcGxlclR5cGVzW3NhbXBsZVR5cGVdO1xuICAgICAgICAgICAgRGVidWcuYXNzZXJ0KGdwdVNhbXBsZXJUeXBlKTtcblxuICAgICAgICAgICAga2V5ICs9IGAjJHtpbmRleH1TOiR7dmlzaWJpbGl0eX0tJHtncHVTYW1wbGVyVHlwZX1gO1xuXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IGluZGV4KyssXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcbiAgICAgICAgICAgICAgICBzYW1wbGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGljYXRlcyB0aGUgcmVxdWlyZWQgdHlwZSBvZiBhIHNhbXBsZXIgYm91bmQgdG8gdGhpcyBiaW5kaW5nc1xuICAgICAgICAgICAgICAgICAgICAvLyAnZmlsdGVyaW5nJywgJ25vbi1maWx0ZXJpbmcnLCAnY29tcGFyaXNvbidcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ3B1U2FtcGxlclR5cGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc3RvcmFnZSB0ZXh0dXJlc1xuICAgICAgICBiaW5kR3JvdXBGb3JtYXQuc3RvcmFnZVRleHR1cmVGb3JtYXRzLmZvckVhY2goKHRleHR1cmVGb3JtYXQpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgeyBmb3JtYXQsIHRleHR1cmVEaW1lbnNpb24gfSA9IHRleHR1cmVGb3JtYXQ7XG4gICAgICAgICAgICBrZXkgKz0gYCMke2luZGV4fVNUOiR7Zm9ybWF0fS0ke3RleHR1cmVEaW1lbnNpb259YDtcblxuICAgICAgICAgICAgLy8gc3RvcmFnZSB0ZXh0dXJlXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IGluZGV4KyssXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSxcbiAgICAgICAgICAgICAgICBzdG9yYWdlVGV4dHVyZToge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhY2Nlc3MgbW9kZSBmb3IgdGhpcyBiaW5kaW5nLCBpbmRpY2F0aW5nIHJlYWRhYmlsaXR5IGFuZCB3cml0YWJpbGl0eS5cbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzOiAnd3JpdGUtb25seScsIC8vIG9ubHkgc2luZ2xlIG9wdGlvbiBjdXJyZW50bHksIG1vcmUgaW4gdGhlIGZ1dHVyZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1aXJlZCBmb3JtYXQgb2YgdGV4dHVyZSB2aWV3cyBib3VuZCB0byB0aGlzIGJpbmRpbmcuXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZ3B1VGV4dHVyZUZvcm1hdHNbZm9ybWF0XSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIGRpbWVuc2lvbiBmb3IgdGV4dHVyZSB2aWV3cyBib3VuZCB0byB0aGlzIGJpbmRpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiMWRcIiwgXCIyZFwiLCBcIjJkLWFycmF5XCIsIFwiY3ViZVwiLCBcImN1YmUtYXJyYXlcIiwgXCIzZFwiXG4gICAgICAgICAgICAgICAgICAgIHZpZXdEaW1lbnNpb246IHRleHR1cmVEaW1lbnNpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtHUFVCaW5kR3JvdXBMYXlvdXREZXNjcmlwdG9yfSAqL1xuICAgICAgICBjb25zdCBkZXNjciA9IHtcbiAgICAgICAgICAgIGVudHJpZXM6IGVudHJpZXNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZGVzY3JcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFdlYmdwdUJpbmRHcm91cEZvcm1hdCB9O1xuIl0sIm5hbWVzIjpbInNhbXBsZXJUeXBlcyIsIlNBTVBMRVRZUEVfRkxPQVQiLCJTQU1QTEVUWVBFX1VORklMVEVSQUJMRV9GTE9BVCIsIlNBTVBMRVRZUEVfREVQVEgiLCJTQU1QTEVUWVBFX0lOVCIsIlNBTVBMRVRZUEVfVUlOVCIsInNhbXBsZVR5cGVzIiwic3RyaW5nSWRzIiwiU3RyaW5nSWRzIiwiV2ViZ3B1QmluZEdyb3VwRm9ybWF0IiwiY29uc3RydWN0b3IiLCJiaW5kR3JvdXBGb3JtYXQiLCJkZXZpY2UiLCJrZXkiLCJkZXNjciIsImNyZWF0ZURlc2NyaXB0b3IiLCJnZXQiLCJEZWJ1ZyIsImNhbGwiLCJiaW5kR3JvdXBMYXlvdXQiLCJ3Z3B1IiwiY3JlYXRlQmluZEdyb3VwTGF5b3V0IiwiRGVidWdIZWxwZXIiLCJzZXRMYWJlbCIsIm5hbWUiLCJkZXN0cm95IiwibG9zZUNvbnRleHQiLCJnZXRUZXh0dXJlU2xvdCIsImluZGV4IiwiYnVmZmVyRm9ybWF0cyIsImxlbmd0aCIsImVudHJpZXMiLCJmb3JFYWNoIiwiYnVmZmVyRm9ybWF0IiwidmlzaWJpbGl0eSIsIldlYmdwdVV0aWxzIiwic2hhZGVyU3RhZ2UiLCJwdXNoIiwiYmluZGluZyIsImJ1ZmZlciIsInR5cGUiLCJoYXNEeW5hbWljT2Zmc2V0IiwidGV4dHVyZUZvcm1hdHMiLCJ0ZXh0dXJlRm9ybWF0Iiwic2FtcGxlVHlwZSIsInZpZXdEaW1lbnNpb24iLCJ0ZXh0dXJlRGltZW5zaW9uIiwibXVsdGlzYW1wbGVkIiwiZ3B1U2FtcGxlVHlwZSIsImFzc2VydCIsInRleHR1cmUiLCJncHVTYW1wbGVyVHlwZSIsInNhbXBsZXIiLCJzdG9yYWdlVGV4dHVyZUZvcm1hdHMiLCJmb3JtYXQiLCJHUFVTaGFkZXJTdGFnZSIsIkNPTVBVVEUiLCJzdG9yYWdlVGV4dHVyZSIsImFjY2VzcyIsImdwdVRleHR1cmVGb3JtYXRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFPQSxNQUFNQSxZQUFZLEdBQUcsRUFBRSxDQUFBO0FBQ3ZCQSxZQUFZLENBQUNDLGdCQUFnQixDQUFDLEdBQUcsV0FBVyxDQUFBO0FBQzVDRCxZQUFZLENBQUNFLDZCQUE2QixDQUFDLEdBQUcsZUFBZSxDQUFBO0FBQzdERixZQUFZLENBQUNHLGdCQUFnQixDQUFDLEdBQUcsWUFBWSxD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
