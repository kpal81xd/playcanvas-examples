import { Debug } from '../../core/debug.js';
import { SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SEMANTIC_COLOR, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT } from './constants.js';
import gles2PS from './shader-chunks/frag/gles2.js';
import gles3PS from './shader-chunks/frag/gles3.js';
import gles3VS from './shader-chunks/vert/gles3.js';
import webgpuPS from './shader-chunks/frag/webgpu.js';
import webgpuVS from './shader-chunks/vert/webgpu.js';
import sharedFS from './shader-chunks/frag/shared.js';

const _attrib2Semantic = {
  vertex_position: SEMANTIC_POSITION,
  vertex_normal: SEMANTIC_NORMAL,
  vertex_tangent: SEMANTIC_TANGENT,
  vertex_texCoord0: SEMANTIC_TEXCOORD0,
  vertex_texCoord1: SEMANTIC_TEXCOORD1,
  vertex_texCoord2: SEMANTIC_TEXCOORD2,
  vertex_texCoord3: SEMANTIC_TEXCOORD3,
  vertex_texCoord4: SEMANTIC_TEXCOORD4,
  vertex_texCoord5: SEMANTIC_TEXCOORD5,
  vertex_texCoord6: SEMANTIC_TEXCOORD6,
  vertex_texCoord7: SEMANTIC_TEXCOORD7,
  vertex_color: SEMANTIC_COLOR,
  vertex_boneIndices: SEMANTIC_BLENDINDICES,
  vertex_boneWeights: SEMANTIC_BLENDWEIGHT
};

/**
 * A class providing utility functions for shader creation.
 *
 * @ignore
 */
class ShaderUtils {
  /**
   * Creates a shader definition.
   *
   * @param {import('./graphics-device.js').GraphicsDevice} device - The graphics device.
   * @param {object} options - Object for passing optional arguments.
   * @param {string} [options.name] - A name of the shader.
   * @param {object} [options.attributes] - Attributes. Will be extracted from the vertexCode if
   * not provided.
   * @param {string} options.vertexCode - The vertex shader code.
   * @param {string} [options.vertexDefines] - The vertex shader defines.
   * @param {string} [options.vertexExtensions] - The vertex shader extensions code.
   * @param {string} [options.fragmentCode] - The fragment shader code.
   * @param {string} [options.fragmentDefines] - The fragment shader defines.
   * @param {string} [options.fragmentExtensions] - The fragment shader extensions code.
   * @param {string} [options.fragmentPreamble] - The preamble string for the fragment shader.
   * @param {boolean} [options.useTransformFeedback] - Whether to use transform feedback. Defaults to false.
   * @param {string | string[]} [options.fragmentOutputTypes] - Fragment shader output types,
   * which default to vec4. Passing a string will set the output type for all color attachments.
   * Passing an array will set the output type for each color attachment.
   * @returns {object} Returns the created shader definition.
   */
  static createDefinition(device, options) {
    var _options$name, _options$attributes;
    Debug.assert(options);
    const getDefines = (gpu, gl2, gl1, isVertex, options) => {
      const deviceIntro = device.isWebGPU ? gpu : device.isWebGL2 ? gl2 : ShaderUtils.gl1Extensions(device, options) + gl1;

      // a define per supported color attachment, which strips out unsupported output definitions in the deviceIntro
      let attachmentsDefine = '';

      // Define the fragment shader output type, vec4 by default
      if (!isVertex) {
        var _options$fragmentOutp;
        // Normalize fragmentOutputTypes to an array
        let fragmentOutputTypes = (_options$fragmentOutp = options.fragmentOutputTypes) != null ? _options$fragmentOutp : 'vec4';
        if (!Array.isArray(fragmentOutputTypes)) {
          fragmentOutputTypes = [fragmentOutputTypes];
        }
        for (let i = 0; i < device.maxColorAttachments; i++) {
          var _fragmentOutputTypes$;
          attachmentsDefine += `#define COLOR_ATTACHMENT_${i}\n`;
          const outType = (_fragmentOutputTypes$ = fragmentOutputTypes[i]) != null ? _fragmentOutputTypes$ : 'vec4';
          attachmentsDefine += `#define outType_${i} ${outType}\n`;
        }
      }
      return attachmentsDefine + deviceIntro;
    };
    const name = (_options$name = options.name) != null ? _options$name : 'Untitled';

    // vertex code
    const vertDefines = options.vertexDefines || getDefines(webgpuVS, gles3VS, '', true, options);
    const vertCode = ShaderUtils.versionCode(device) + vertDefines + sharedFS + ShaderUtils.getShaderNameCode(name) + options.vertexCode;

    // fragment code
    const fragDefines = options.fragmentDefines || getDefines(webgpuPS, gles3PS, gles2PS, false, options);
    const fragCode = (options.fragmentPreamble || '') + ShaderUtils.versionCode(device) + fragDefines + ShaderUtils.precisionCode(device) + '\n' + sharedFS + ShaderUtils.getShaderNameCode(name) + (options.fragmentCode || ShaderUtils.dummyFragmentCode());

    // attributes
    const attribs = (_options$attributes = options.attributes) != null ? _options$attributes : ShaderUtils.collectAttributes(options.vertexCode);
    return {
      name: name,
      attributes: attribs,
      vshader: vertCode,
      fshader: fragCode,
      useTransformFeedback: options.useTransformFeedback
    };
  }

  // SpectorJS integration
  static getShaderNameCode(name) {
    return `#define SHADER_NAME ${name}\n`;
  }
  static gl1Extensions(device, options, isVertex) {
    let code;
    if (isVertex) {
      code = options.vertexExtensions ? `${options.vertexExtensions}\n` : '';
    } else {
      code = options.fragmentExtensions ? `${options.fragmentExtensions}\n` : '';

      // extensions used by default
      if (device.extStandardDerivatives) {
        code += "#extension GL_OES_standard_derivatives : enable\n";
      }
      if (device.extTextureLod) {
        code += "#extension GL_EXT_shader_texture_lod : enable\n";
        code += "#define SUPPORTS_TEXLOD\n";
      }
      if (device.extDrawBuffers) {
        code += "#extension GL_EXT_draw_buffers : require\n";
        code += "#define SUPPORTS_MRT\n";
      }
    }
    return code;
  }
  static dummyFragmentCode() {
    return "void main(void) {gl_FragColor = vec4(0.0);}";
  }
  static versionCode(device) {
    if (device.isWebGPU) {
      return '#version 450\n';
    }
    return device.isWebGL2 ? "#version 300 es\n" : "";
  }
  static precisionCode(device, forcePrecision) {
    let code = '';
    if (forcePrecision && forcePrecision !== 'highp' && forcePrecision !== 'mediump' && forcePrecision !== 'lowp') {
      forcePrecision = null;
    }
    if (forcePrecision) {
      if (forcePrecision === 'highp' && device.maxPrecision !== 'highp') {
        forcePrecision = 'mediump';
      }
      if (forcePrecision === 'mediump' && device.maxPrecision === 'lowp') {
        forcePrecision = 'lowp';
      }
    }
    const precision = forcePrecision ? forcePrecision : device.precision;
    if (!device.isWebGPU) {
      code = `precision ${precision} float;\n`;
      if (device.isWebGL2) {
        code += `precision ${precision} sampler2DShadow;\n`;
      }
    } else {
      // WebGPU

      code = `precision ${precision} float;\nprecision ${precision} int;\n`;
    }
    return code;
  }

  /**
   * Extract the attributes specified in a vertex shader.
   *
   * @param {string} vsCode - The vertex shader code.
   * @returns {Object<string, string>} The attribute name to semantic map.
   * @ignore
   */
  static collectAttributes(vsCode) {
    const attribs = {};
    let attrs = 0;
    let found = vsCode.indexOf("attribute");
    while (found >= 0) {
      if (found > 0 && vsCode[found - 1] === "/") break;
      const endOfLine = vsCode.indexOf(';', found);
      const startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
      const attribName = vsCode.substring(startOfAttribName + 1, endOfLine);
      const semantic = _attrib2Semantic[attribName];
      if (semantic !== undefined) {
        attribs[attribName] = semantic;
      } else {
        attribs[attribName] = "ATTR" + attrs;
        attrs++;
      }
      found = vsCode.indexOf("attribute", found + 1);
    }
    return attribs;
  }
}

export { ShaderUtils };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhZGVyLXV0aWxzLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvcGxhdGZvcm0vZ3JhcGhpY3Mvc2hhZGVyLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlYnVnIH0gZnJvbSBcIi4uLy4uL2NvcmUvZGVidWcuanNcIjtcbmltcG9ydCB7XG4gICAgU0VNQU5USUNfUE9TSVRJT04sIFNFTUFOVElDX05PUk1BTCwgU0VNQU5USUNfVEFOR0VOVCwgU0VNQU5USUNfVEVYQ09PUkQwLCBTRU1BTlRJQ19URVhDT09SRDEsIFNFTUFOVElDX1RFWENPT1JEMixcbiAgICBTRU1BTlRJQ19URVhDT09SRDMsIFNFTUFOVElDX1RFWENPT1JENCwgU0VNQU5USUNfVEVYQ09PUkQ1LCBTRU1BTlRJQ19URVhDT09SRDYsIFNFTUFOVElDX1RFWENPT1JENyxcbiAgICBTRU1BTlRJQ19DT0xPUiwgU0VNQU5USUNfQkxFTkRJTkRJQ0VTLCBTRU1BTlRJQ19CTEVORFdFSUdIVFxufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbmltcG9ydCBnbGVzMkZTIGZyb20gJy4vc2hhZGVyLWNodW5rcy9mcmFnL2dsZXMyLmpzJztcbmltcG9ydCBnbGVzM0ZTIGZyb20gJy4vc2hhZGVyLWNodW5rcy9mcmFnL2dsZXMzLmpzJztcbmltcG9ydCBnbGVzM1ZTIGZyb20gJy4vc2hhZGVyLWNodW5rcy92ZXJ0L2dsZXMzLmpzJztcbmltcG9ydCB3ZWJncHVGUyBmcm9tICcuL3NoYWRlci1jaHVua3MvZnJhZy93ZWJncHUuanMnO1xuaW1wb3J0IHdlYmdwdVZTIGZyb20gJy4vc2hhZGVyLWNodW5rcy92ZXJ0L3dlYmdwdS5qcyc7XG5pbXBvcnQgc2hhcmVkRlMgZnJvbSAnLi9zaGFkZXItY2h1bmtzL2ZyYWcvc2hhcmVkLmpzJztcblxuY29uc3QgX2F0dHJpYjJTZW1hbnRpYyA9IHtcbiAgICB2ZXJ0ZXhfcG9zaXRpb246IFNFTUFOVElDX1BPU0lUSU9OLFxuICAgIHZlcnRleF9ub3JtYWw6IFNFTUFOVElDX05PUk1BTCxcbiAgICB2ZXJ0ZXhfdGFuZ2VudDogU0VNQU5USUNfVEFOR0VOVCxcbiAgICB2ZXJ0ZXhfdGV4Q29vcmQwOiBTRU1BTlRJQ19URVhDT09SRDAsXG4gICAgdmVydGV4X3RleENvb3JkMTogU0VNQU5USUNfVEVYQ09PUkQxLFxuICAgIHZlcnRleF90ZXhDb29yZDI6IFNFTUFOVElDX1RFWENPT1JEMixcbiAgICB2ZXJ0ZXhfdGV4Q29vcmQzOiBTRU1BTlRJQ19URVhDT09SRDMsXG4gICAgdmVydGV4X3RleENvb3JkNDogU0VNQU5USUNfVEVYQ09PUkQ0LFxuICAgIHZlcnRleF90ZXhDb29yZDU6IFNFTUFOVElDX1RFWENPT1JENSxcbiAgICB2ZXJ0ZXhfdGV4Q29vcmQ2OiBTRU1BTlRJQ19URVhDT09SRDYsXG4gICAgdmVydGV4X3RleENvb3JkNzogU0VNQU5USUNfVEVYQ09PUkQ3LFxuICAgIHZlcnRleF9jb2xvcjogU0VNQU5USUNfQ09MT1IsXG4gICAgdmVydGV4X2JvbmVJbmRpY2VzOiBTRU1BTlRJQ19CTEVORElORElDRVMsXG4gICAgdmVydGV4X2JvbmVXZWlnaHRzOiBTRU1BTlRJQ19CTEVORFdFSUdIVFxufTtcblxuLyoqXG4gKiBBIGNsYXNzIHByb3ZpZGluZyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3Igc2hhZGVyIGNyZWF0aW9uLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgU2hhZGVyVXRpbHMge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFkZXIgZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuL2dyYXBoaWNzLWRldmljZS5qcycpLkdyYXBoaWNzRGV2aWNlfSBkZXZpY2UgLSBUaGUgZ3JhcGhpY3MgZGV2aWNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IGZvciBwYXNzaW5nIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gLSBBIG5hbWUgb2YgdGhlIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuYXR0cmlidXRlc10gLSBBdHRyaWJ1dGVzLiBXaWxsIGJlIGV4dHJhY3RlZCBmcm9tIHRoZSB2ZXJ0ZXhDb2RlIGlmXG4gICAgICogbm90IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnZlcnRleENvZGUgLSBUaGUgdmVydGV4IHNoYWRlciBjb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52ZXJ0ZXhEZWZpbmVzXSAtIFRoZSB2ZXJ0ZXggc2hhZGVyIGRlZmluZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZlcnRleEV4dGVuc2lvbnNdIC0gVGhlIHZlcnRleCBzaGFkZXIgZXh0ZW5zaW9ucyBjb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mcmFnbWVudENvZGVdIC0gVGhlIGZyYWdtZW50IHNoYWRlciBjb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mcmFnbWVudERlZmluZXNdIC0gVGhlIGZyYWdtZW50IHNoYWRlciBkZWZpbmVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mcmFnbWVudEV4dGVuc2lvbnNdIC0gVGhlIGZyYWdtZW50IHNoYWRlciBleHRlbnNpb25zIGNvZGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZyYWdtZW50UHJlYW1ibGVdIC0gVGhlIHByZWFtYmxlIHN0cmluZyBmb3IgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVzZVRyYW5zZm9ybUZlZWRiYWNrXSAtIFdoZXRoZXIgdG8gdXNlIHRyYW5zZm9ybSBmZWVkYmFjay4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gW29wdGlvbnMuZnJhZ21lbnRPdXRwdXRUeXBlc10gLSBGcmFnbWVudCBzaGFkZXIgb3V0cHV0IHR5cGVzLFxuICAgICAqIHdoaWNoIGRlZmF1bHQgdG8gdmVjNC4gUGFzc2luZyBhIHN0cmluZyB3aWxsIHNldCB0aGUgb3V0cHV0IHR5cGUgZm9yIGFsbCBjb2xvciBhdHRhY2htZW50cy5cbiAgICAgKiBQYXNzaW5nIGFuIGFycmF5IHdpbGwgc2V0IHRoZSBvdXRwdXQgdHlwZSBmb3IgZWFjaCBjb2xvciBhdHRhY2htZW50LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFJldHVybnMgdGhlIGNyZWF0ZWQgc2hhZGVyIGRlZmluaXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURlZmluaXRpb24oZGV2aWNlLCBvcHRpb25zKSB7XG4gICAgICAgIERlYnVnLmFzc2VydChvcHRpb25zKTtcblxuICAgICAgICBjb25zdCBnZXREZWZpbmVzID0gKGdwdSwgZ2wyLCBnbDEsIGlzVmVydGV4LCBvcHRpb25zKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGRldmljZUludHJvID0gZGV2aWNlLmlzV2ViR1BVID8gZ3B1IDpcbiAgICAgICAgICAgICAgICAoZGV2aWNlLmlzV2ViR0wyID8gZ2wyIDogU2hhZGVyVXRpbHMuZ2wxRXh0ZW5zaW9ucyhkZXZpY2UsIG9wdGlvbnMpICsgZ2wxKTtcblxuICAgICAgICAgICAgLy8gYSBkZWZpbmUgcGVyIHN1cHBvcnRlZCBjb2xvciBhdHRhY2htZW50LCB3aGljaCBzdHJpcHMgb3V0IHVuc3VwcG9ydGVkIG91dHB1dCBkZWZpbml0aW9ucyBpbiB0aGUgZGV2aWNlSW50cm9cbiAgICAgICAgICAgIGxldCBhdHRhY2htZW50c0RlZmluZSA9ICcnO1xuXG4gICAgICAgICAgICAvLyBEZWZpbmUgdGhlIGZyYWdtZW50IHNoYWRlciBvdXRwdXQgdHlwZSwgdmVjNCBieSBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoIWlzVmVydGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsaXplIGZyYWdtZW50T3V0cHV0VHlwZXMgdG8gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnRPdXRwdXRUeXBlcyA9IG9wdGlvbnMuZnJhZ21lbnRPdXRwdXRUeXBlcyA/PyAndmVjNCc7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyYWdtZW50T3V0cHV0VHlwZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50T3V0cHV0VHlwZXMgPSBbZnJhZ21lbnRPdXRwdXRUeXBlc107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXZpY2UubWF4Q29sb3JBdHRhY2htZW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzRGVmaW5lICs9IGAjZGVmaW5lIENPTE9SX0FUVEFDSE1FTlRfJHtpfVxcbmA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dFR5cGUgPSBmcmFnbWVudE91dHB1dFR5cGVzW2ldID8/ICd2ZWM0JztcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHNEZWZpbmUgKz0gYCNkZWZpbmUgb3V0VHlwZV8ke2l9ICR7b3V0VHlwZX1cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF0dGFjaG1lbnRzRGVmaW5lICsgZGV2aWNlSW50cm87XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbmFtZSA9IG9wdGlvbnMubmFtZSA/PyAnVW50aXRsZWQnO1xuXG4gICAgICAgIC8vIHZlcnRleCBjb2RlXG4gICAgICAgIGNvbnN0IHZlcnREZWZpbmVzID0gb3B0aW9ucy52ZXJ0ZXhEZWZpbmVzIHx8IGdldERlZmluZXMod2ViZ3B1VlMsIGdsZXMzVlMsICcnLCB0cnVlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdmVydENvZGUgPSBTaGFkZXJVdGlscy52ZXJzaW9uQ29kZShkZXZpY2UpICtcbiAgICAgICAgICAgIHZlcnREZWZpbmVzICtcbiAgICAgICAgICAgIHNoYXJlZEZTICtcbiAgICAgICAgICAgIFNoYWRlclV0aWxzLmdldFNoYWRlck5hbWVDb2RlKG5hbWUpICtcbiAgICAgICAgICAgIG9wdGlvbnMudmVydGV4Q29kZTtcblxuICAgICAgICAvLyBmcmFnbWVudCBjb2RlXG4gICAgICAgIGNvbnN0IGZyYWdEZWZpbmVzID0gb3B0aW9ucy5mcmFnbWVudERlZmluZXMgfHwgZ2V0RGVmaW5lcyh3ZWJncHVGUywgZ2xlczNGUywgZ2xlczJGUywgZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmcmFnQ29kZSA9IChvcHRpb25zLmZyYWdtZW50UHJlYW1ibGUgfHwgJycpICtcbiAgICAgICAgICAgIFNoYWRlclV0aWxzLnZlcnNpb25Db2RlKGRldmljZSkgK1xuICAgICAgICAgICAgZnJhZ0RlZmluZXMgK1xuICAgICAgICAgICAgU2hhZGVyVXRpbHMucHJlY2lzaW9uQ29kZShkZXZpY2UpICsgJ1xcbicgK1xuICAgICAgICAgICAgc2hhcmVkRlMgK1xuICAgICAgICAgICAgU2hhZGVyVXRpbHMuZ2V0U2hhZGVyTmFtZUNvZGUobmFtZSkgK1xuICAgICAgICAgICAgKG9wdGlvbnMuZnJhZ21lbnRDb2RlIHx8IFNoYWRlclV0aWxzLmR1bW15RnJhZ21lbnRDb2RlKCkpO1xuXG4gICAgICAgIC8vIGF0dHJpYnV0ZXNcbiAgICAgICAgY29uc3QgYXR0cmlicyA9IG9wdGlvbnMuYXR0cmlidXRlcyA/PyBTaGFkZXJVdGlscy5jb2xsZWN0QXR0cmlidXRlcyhvcHRpb25zLnZlcnRleENvZGUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlicyxcbiAgICAgICAgICAgIHZzaGFkZXI6IHZlcnRDb2RlLFxuICAgICAgICAgICAgZnNoYWRlcjogZnJhZ0NvZGUsXG4gICAgICAgICAgICB1c2VUcmFuc2Zvcm1GZWVkYmFjazogb3B0aW9ucy51c2VUcmFuc2Zvcm1GZWVkYmFja1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFNwZWN0b3JKUyBpbnRlZ3JhdGlvblxuICAgIHN0YXRpYyBnZXRTaGFkZXJOYW1lQ29kZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgI2RlZmluZSBTSEFERVJfTkFNRSAke25hbWV9XFxuYDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2wxRXh0ZW5zaW9ucyhkZXZpY2UsIG9wdGlvbnMsIGlzVmVydGV4KSB7XG4gICAgICAgIGxldCBjb2RlO1xuICAgICAgICBpZiAoaXNWZXJ0ZXgpIHtcbiAgICAgICAgICAgIGNvZGUgPSBvcHRpb25zLnZlcnRleEV4dGVuc2lvbnMgPyBgJHtvcHRpb25zLnZlcnRleEV4dGVuc2lvbnN9XFxuYCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZSA9IG9wdGlvbnMuZnJhZ21lbnRFeHRlbnNpb25zID8gYCR7b3B0aW9ucy5mcmFnbWVudEV4dGVuc2lvbnN9XFxuYCA6ICcnO1xuXG4gICAgICAgICAgICAvLyBleHRlbnNpb25zIHVzZWQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKGRldmljZS5leHRTdGFuZGFyZERlcml2YXRpdmVzKSB7XG4gICAgICAgICAgICAgICAgY29kZSArPSBcIiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2aWNlLmV4dFRleHR1cmVMb2QpIHtcbiAgICAgICAgICAgICAgICBjb2RlICs9IFwiI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlXFxuXCI7XG4gICAgICAgICAgICAgICAgY29kZSArPSBcIiNkZWZpbmUgU1VQUE9SVFNfVEVYTE9EXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2aWNlLmV4dERyYXdCdWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgY29kZSArPSBcIiNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG5cIjtcbiAgICAgICAgICAgICAgICBjb2RlICs9IFwiI2RlZmluZSBTVVBQT1JUU19NUlRcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cblxuICAgIHN0YXRpYyBkdW1teUZyYWdtZW50Q29kZSgpIHtcbiAgICAgICAgcmV0dXJuIFwidm9pZCBtYWluKHZvaWQpIHtnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7fVwiO1xuICAgIH1cblxuICAgIHN0YXRpYyB2ZXJzaW9uQ29kZShkZXZpY2UpIHtcbiAgICAgICAgaWYgKGRldmljZS5pc1dlYkdQVSkge1xuICAgICAgICAgICAgcmV0dXJuICcjdmVyc2lvbiA0NTBcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXZpY2UuaXNXZWJHTDIgPyBcIiN2ZXJzaW9uIDMwMCBlc1xcblwiIDogXCJcIjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJlY2lzaW9uQ29kZShkZXZpY2UsIGZvcmNlUHJlY2lzaW9uKSB7XG5cbiAgICAgICAgbGV0IGNvZGUgPSAnJztcblxuICAgICAgICBpZiAoZm9yY2VQcmVjaXNpb24gJiYgZm9yY2VQcmVjaXNpb24gIT09ICdoaWdocCcgJiYgZm9yY2VQcmVjaXNpb24gIT09ICdtZWRpdW1wJyAmJiBmb3JjZVByZWNpc2lvbiAhPT0gJ2xvd3AnKSB7XG4gICAgICAgICAgICBmb3JjZVByZWNpc2lvbiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VQcmVjaXNpb24pIHtcbiAgICAgICAgICAgIGlmIChmb3JjZVByZWNpc2lvbiA9PT0gJ2hpZ2hwJyAmJiBkZXZpY2UubWF4UHJlY2lzaW9uICE9PSAnaGlnaHAnKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VQcmVjaXNpb24gPSAnbWVkaXVtcCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9yY2VQcmVjaXNpb24gPT09ICdtZWRpdW1wJyAmJiBkZXZpY2UubWF4UHJlY2lzaW9uID09PSAnbG93cCcpIHtcbiAgICAgICAgICAgICAgICBmb3JjZVByZWNpc2lvbiA9ICdsb3dwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IGZvcmNlUHJlY2lzaW9uID8gZm9yY2VQcmVjaXNpb24gOiBkZXZpY2UucHJlY2lzaW9uO1xuXG4gICAgICAgIGlmICghZGV2aWNlLmlzV2ViR1BVKSB7XG5cbiAgICAgICAgICAgIGNvZGUgPSBgcHJlY2lzaW9uICR7cHJlY2lzaW9ufSBmbG9hdDtcXG5gO1xuXG4gICAgICAgICAgICBpZiAoZGV2aWNlLmlzV2ViR0wyKSB7XG4gICAgICAgICAgICAgICAgY29kZSArPSBgcHJlY2lzaW9uICR7cHJlY2lzaW9ufSBzYW1wbGVyMkRTaGFkb3c7XFxuYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBXZWJHUFVcblxuICAgICAgICAgICAgY29kZSA9IGBwcmVjaXNpb24gJHtwcmVjaXNpb259IGZsb2F0O1xcbnByZWNpc2lvbiAke3ByZWNpc2lvbn0gaW50O1xcbmA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBhdHRyaWJ1dGVzIHNwZWNpZmllZCBpbiBhIHZlcnRleCBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdnNDb2RlIC0gVGhlIHZlcnRleCBzaGFkZXIgY29kZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHNlbWFudGljIG1hcC5cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgc3RhdGljIGNvbGxlY3RBdHRyaWJ1dGVzKHZzQ29kZSkge1xuICAgICAgICBjb25zdCBhdHRyaWJzID0ge307XG4gICAgICAgIGxldCBhdHRycyA9IDA7XG5cbiAgICAgICAgbGV0IGZvdW5kID0gdnNDb2RlLmluZGV4T2YoXCJhdHRyaWJ1dGVcIik7XG4gICAgICAgIHdoaWxlIChmb3VuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAwICYmIHZzQ29kZVtmb3VuZCAtIDFdID09PSBcIi9cIikgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCBlbmRPZkxpbmUgPSB2c0NvZGUuaW5kZXhPZignOycsIGZvdW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2ZBdHRyaWJOYW1lID0gdnNDb2RlLmxhc3RJbmRleE9mKCcgJywgZW5kT2ZMaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYk5hbWUgPSB2c0NvZGUuc3Vic3RyaW5nKHN0YXJ0T2ZBdHRyaWJOYW1lICsgMSwgZW5kT2ZMaW5lKTtcblxuICAgICAgICAgICAgY29uc3Qgc2VtYW50aWMgPSBfYXR0cmliMlNlbWFudGljW2F0dHJpYk5hbWVdO1xuICAgICAgICAgICAgaWYgKHNlbWFudGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJzW2F0dHJpYk5hbWVdID0gc2VtYW50aWM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnNbYXR0cmliTmFtZV0gPSBcIkFUVFJcIiArIGF0dHJzO1xuICAgICAgICAgICAgICAgIGF0dHJzKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvdW5kID0gdnNDb2RlLmluZGV4T2YoXCJhdHRyaWJ1dGVcIiwgZm91bmQgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdHRyaWJzO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU2hhZGVyVXRpbHMgfTtcbiJdLCJuYW1lcyI6WyJfYXR0cmliMlNlbWFudGljIiwidmVydGV4X3Bvc2l0aW9uIiwiU0VNQU5USUNfUE9TSVRJT04iLCJ2ZXJ0ZXhfbm9ybWFsIiwiU0VNQU5USUNfTk9STUFMIiwidmVydGV4X3RhbmdlbnQiLCJTRU1BTlRJQ19UQU5HRU5UIiwidmVydGV4X3RleENvb3JkMCIsIlNFTUFOVElDX1RFWENPT1JEMCIsInZlcnRleF90ZXhDb29yZDEiLCJTRU1BTlRJQ19URVhDT09SRDEiLCJ2ZXJ0ZXhfdGV4Q29vcmQyIiwiU0VNQU5USUNfVEVYQ09PUkQyIiwidmVydGV4X3RleENvb3JkMyIsIlNFTUFOVElDX1RFWENPT1JEMyIsInZlcnRleF90ZXhDb29yZDQiLCJTRU1BTlRJQ19URVhDT09SRDQiLCJ2ZXJ0ZXhfdGV4Q29vcmQ1IiwiU0VNQU5USUNfVEVYQ09PUkQ1IiwidmVydGV4X3RleENvb3JkNiIsIlNFTUFOVElDX1RFWENPT1JENiIsInZlcnRleF90ZXhDb29yZDciLCJTRU1BTlRJQ19URVhDT09SRDciLCJ2ZXJ0ZXhfY29sb3IiLCJTRU1BTlRJQ19DT0xPUiIsInZlcnRleF9ib25lSW5kaWNlcyIsIlNFTUFOVElDX0JMRU5ESU5ESUNFUyIsInZlcnRleF9ib25lV2VpZ2h0cyIsIlNFTUFOVElDX0JMRU5EV0VJR0hUIiwiU2hhZGVyVXRpbHMiLCJjcmVhdGVEZWZpbml0aW9uIiwiZGV2aWNlIiwib3B0aW9ucyIsIl9vcHRpb25zJG5hbWUiLCJfb3B0aW9ucyRhdHRyaWJ1dGVzIiwiRGVidWciLCJhc3NlcnQiLCJnZXREZWZpbmVzIiwiZ3B1IiwiZ2wyIiwiZ2wxIiwiaXNWZXJ0ZXgiLCJkZXZpY2VJbnRybyIsImlzV2ViR1BVIiwiaXNXZWJHTDIiLCJnbDFFeHRlbnNpb25zIiwiYXR0YWNobWVudHNEZWZpbmUiLCJfb3B0aW9ucyRmcmFnbWVudE91dHAiLCJmcmFnbWVudE91dHB1dFR5cGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiaSIsIm1heENvbG9yQXR0YWNobWVudHMiLCJfZnJhZ21lbnRPdXRwdXRUeXBlcyQiLCJvdXRUeXBlIiwibmFtZSIsInZlcnREZWZpbmVzIiwidmVydGV4RGVmaW5lcyIsIndlYmdwdVZTIiwiZ2xlczNWUyIsInZlcnRDb2RlIiwidmVyc2lvbkNvZGUiLCJzaGFyZWRGUyIsImdldFNoYWRlck5hbWVDb2RlIiwidmVydGV4Q29kZSIsImZyYWdEZWZpbmVzIiwiZnJhZ21lbnREZWZpbmVzIiwid2ViZ3B1RlMiLCJnbGVzM0ZTIiwiZ2xlczJGUyIsImZyYWdDb2RlIiwiZnJhZ21lbnRQcmVhbWJsZSIsInByZWNpc2lvbkNvZGUiLCJmcmFnbWVudENvZGUiLCJkdW1teUZyYWdtZW50Q29kZSIsImF0dHJpYnMiLCJhdHRyaWJ1dGVzIiwiY29sbGVjdEF0dHJpYnV0ZXMiLCJ2c2hhZGVyIiwiZnNoYWRlciIsInVzZVRyYW5zZm9ybUZlZWRiYWNrIiwiY29kZSIsInZlcnRleEV4dGVuc2lvbnMiLCJmcmFnbWVudEV4dGVuc2lvbnMiLCJleHRTdGFuZGFyZERlcml2YXRpdmVzIiwiZXh0VGV4dHVyZUxvZCIsImV4dERyYXdCdWZmZXJzIiwiZm9yY2VQcmVjaXNpb24iLCJtYXhQcmVjaXNpb24iLCJwcmVjaXNpb24iLCJ2c0NvZGUiLCJhdHRycyIsImZvdW5kIiwiaW5kZXhPZiIsImVuZE9mTGluZSIsInN0YXJ0T2ZBdHRyaWJOYW1lIiwibGFzdEluZGV4T2YiLCJhdHRyaWJOYW1lIiwic3Vic3RyaW5nIiwic2VtYW50aWMiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQWNBLE1BQU1BLGdCQUFnQixHQUFHO0FBQ3JCQyxFQUFBQSxlQUFlLEVBQUVDLGlCQUFpQjtBQUNsQ0MsRUFBQUEsYUFBYSxFQUFFQyxlQUFlO0FBQzlCQyxFQUFBQSxjQUFjLEVBQUVDLGdCQUFnQjtBQUNoQ0MsRUFBQUEsZ0JBQWdCLEVBQUVDLGtCQUFrQjtBQUNwQ0MsRUFBQUEsZ0JBQWdCLEVBQUVDLGtCQUFrQjtBQUNwQ0MsRUFBQUEsZ0JBQWdCLEVBQUVDLGtCQUFrQjtBQUNwQ0MsRUFBQUEsZ0JBQWdCLEVBQUVDLGtCQUFrQjtBQUNwQ0MsRUFB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
